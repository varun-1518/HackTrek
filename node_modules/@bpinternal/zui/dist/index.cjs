"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  ErrorBoundary: () => ErrorBoundary,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseInputLazyPath: () => ParseInputLazyPath,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  UntitledDeclarationError: () => UntitledDeclarationError,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodRef: () => ZodRef,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTemplateLiteralUnsupportedCheckError: () => ZodTemplateLiteralUnsupportedCheckError,
  ZodTemplateLiteralUnsupportedTypeError: () => ZodTemplateLiteralUnsupportedTypeError,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZuiForm: () => ZuiForm,
  addIssueToContext: () => addIssueToContext,
  agent: () => agent,
  aimodel: () => aimodel,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  conversation: () => conversation,
  createZodEnum: () => createZodEnum,
  cuid2Regex: () => cuid2Regex,
  cuidRegex: () => cuidRegex,
  custom: () => custom,
  datasource: () => datasource,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultComponentDefinitions: () => defaultComponentDefinitions,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  emailRegex: () => emailRegex,
  enum: () => enumType,
  errorUtil: () => errorUtil,
  event: () => event,
  fromJsonSchema: () => fromJsonSchema,
  fromObject: () => fromObject,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intent: () => intent,
  intersection: () => intersectionType,
  ipv4Regex: () => ipv4Regex,
  ipv6Regex: () => ipv6Regex,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isEmojiRegex: () => isEmojiRegex,
  isValid: () => isValid,
  jsonSchemaToZui: () => jsonSchemaToZui,
  knowledgebase: () => knowledgebase,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  message: () => message,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectToZui: () => objectToZui,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  processCreateParams: () => processCreateParams,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  readonly: () => readonlyType,
  record: () => recordType,
  ref: () => refType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  table: () => table,
  tablerow: () => tablerow,
  templateLiteral: () => templateLiteralType,
  transformer: () => effectsType,
  transforms: () => transforms,
  tuple: () => tupleType,
  ulidRegex: () => ulidRegex,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  user: () => user,
  util: () => util,
  uuidRegex: () => uuidRegex,
  variable: () => variable,
  void: () => voidType,
  withErrorBoundary: () => withErrorBoundary,
  z: () => z_exports,
  zuiToJsonSchema: () => zuiToJsonSchema
});
module.exports = __toCommonJS(src_exports);

// src/z/z.ts
var z_exports = {};
__export(z_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseInputLazyPath: () => ParseInputLazyPath,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodRef: () => ZodRef,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTemplateLiteralUnsupportedCheckError: () => ZodTemplateLiteralUnsupportedCheckError,
  ZodTemplateLiteralUnsupportedTypeError: () => ZodTemplateLiteralUnsupportedTypeError,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  agent: () => agent,
  aimodel: () => aimodel,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  conversation: () => conversation,
  createZodEnum: () => createZodEnum,
  cuid2Regex: () => cuid2Regex,
  cuidRegex: () => cuidRegex,
  custom: () => custom,
  datasource: () => datasource,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  default: () => defaultType,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  emailRegex: () => emailRegex,
  enum: () => enumType,
  errorUtil: () => errorUtil,
  event: () => event,
  fromJsonSchema: () => fromJsonSchema,
  fromObject: () => fromObject,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intent: () => intent,
  intersection: () => intersectionType,
  ipv4Regex: () => ipv4Regex,
  ipv6Regex: () => ipv6Regex,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isEmojiRegex: () => isEmojiRegex,
  isValid: () => isValid,
  jsonSchemaToZui: () => jsonSchemaToZui,
  knowledgebase: () => knowledgebase,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  message: () => message,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectToZui: () => objectToZui,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  processCreateParams: () => processCreateParams,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  readonly: () => readonlyType,
  record: () => recordType,
  ref: () => refType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  table: () => table,
  tablerow: () => tablerow,
  templateLiteral: () => templateLiteralType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  ulidRegex: () => ulidRegex,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  user: () => user,
  util: () => util,
  uuidRegex: () => uuidRegex,
  variable: () => variable,
  void: () => voidType,
  zuiToJsonSchema: () => zuiToJsonSchema
});

// src/ui/constants.ts
var zuiKey = "x-zui";

// src/ui/hooks/useDiscriminator.ts
var import_react2 = require("react");

// src/ui/hooks/useFormData.tsx
var import_react = __toESM(require("react"), 1);
var FormDataContext = (0, import_react.createContext)({
  formData: void 0,
  formSchema: void 0,
  setFormData: () => {
    throw new Error("Must be within a FormDataProvider");
  },
  setHiddenState: () => {
    throw new Error("Must be within a FormDataProvider");
  },
  setDisabledState: () => {
    throw new Error("Must be within a FormDataProvider");
  },
  hiddenState: {},
  disabledState: {},
  validation: { formValid: null, formErrors: null }
});
var parseMaskableField = /* @__PURE__ */ __name((key, fieldSchema, data) => {
  var _a;
  const value = (_a = fieldSchema[zuiKey]) == null ? void 0 : _a[key];
  if (typeof value === "undefined") {
    return false;
  }
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "string") {
    if (typeof window === "undefined") {
      console.warn("Function evaluation is not supported in server side rendering");
      return false;
    }
    const func = new Function("return " + value)();
    const result = func(data);
    switch (typeof result) {
      case "object":
      case "boolean":
        return result;
      default:
        return false;
    }
  }
  return false;
}, "parseMaskableField");
var useFormData = /* @__PURE__ */ __name((fieldSchema, path) => {
  const formContext = (0, import_react.useContext)(FormDataContext);
  if (formContext === void 0) {
    throw new Error("useFormData must be used within a FormDataProvider");
  }
  const data = (0, import_react.useMemo)(() => getPathData(formContext.formData, path), [formContext.formData, path]);
  const validation = (0, import_react.useMemo)(() => {
    var _a;
    if (formContext.validation.formValid === null) {
      return { formValid: null, formErrors: null };
    }
    if (formContext.validation.formValid === false) {
      return {
        formValid: false,
        formErrors: ((_a = formContext.validation.formErrors) == null ? void 0 : _a.filter((issue) => pathMatches(issue.path, path)).map((issue) => ({
          message: issue.message,
          code: issue.code,
          path
        }))) || null
      };
    }
    return { formValid: true, formErrors: [] };
  }, [formContext.validation.formValid, formContext.validation.formErrors, path]);
  const transformedData = formContext.dataTransform ? formContext.dataTransform(data) : data;
  const hiddenMask = (0, import_react.useMemo)(
    () => parseMaskableField("hidden", fieldSchema, transformedData),
    [fieldSchema, transformedData]
  );
  const disabledMask = (0, import_react.useMemo)(
    () => parseMaskableField("disabled", fieldSchema, transformedData),
    [fieldSchema, transformedData]
  );
  (0, import_react.useEffect)(() => {
    formContext.setHiddenState((hiddenState) => setObjectPath(hiddenState, path, hiddenMask || {}));
    formContext.setDisabledState((disabledState) => setObjectPath(disabledState, path, disabledMask || {}));
  }, [JSON.stringify({ fieldSchema, data })]);
  const { disabled, hidden } = (0, import_react.useMemo)(() => {
    const hidden2 = hiddenMask === true || getPathData(formContext.hiddenState, path);
    const disabled2 = disabledMask === true || getPathData(formContext.disabledState, path);
    return { hidden: hidden2 === true, disabled: disabled2 === true };
  }, [formContext.hiddenState, formContext.disabledState, hiddenMask, disabledMask, path]);
  const handlePropertyChange = (0, import_react.useCallback)(
    (path2, data2) => {
      formContext.setFormData((formData) => setObjectPath(formData, path2, data2));
    },
    [formContext.setFormData]
  );
  const addArrayItem = (0, import_react.useCallback)(
    (path2, data2 = void 0) => {
      const defaultData = getDefaultValues(fieldSchema.items);
      formContext.setFormData((formData) => {
        const currentData = getPathData(formData, path2) || [];
        if (data2 === void 0) {
          data2 = defaultData;
        }
        return setObjectPath(formData, path2, Array.isArray(currentData) ? [...currentData, data2] : [data2]);
      });
    },
    [formContext.setFormData]
  );
  const removeArrayItem = (0, import_react.useCallback)(
    (path2, index) => {
      formContext.setFormData((formData) => {
        const currentData = getPathData(formData, path2) || [];
        if (!Array.isArray(currentData)) {
          return formData;
        }
        currentData.splice(index, 1);
        return setObjectPath(formData, path2, currentData);
      });
    },
    [formContext.setFormData]
  );
  return __spreadValues(__spreadProps(__spreadValues({}, formContext), { data, disabled, hidden, handlePropertyChange, addArrayItem, removeArrayItem }), validation);
}, "useFormData");
function setObjectPath(obj, path, data) {
  if (path.length === 0) {
    return data;
  }
  const pathLength = path.length;
  path.reduce((current, key, index) => {
    if (index === pathLength - 1) {
      current[key] = data;
    } else {
      if (!current[key]) {
        current[key] = isNaN(Number(key)) ? {} : [];
      }
    }
    return current[key];
  }, obj != null ? obj : {});
  return __spreadValues({}, obj);
}
__name(setObjectPath, "setObjectPath");
var getDefaultValues = /* @__PURE__ */ __name((schema, optional) => {
  var _a, _b, _c, _d;
  if (Array.isArray(schema)) {
    return getDefaultValues(schema[0]);
  }
  if (schema.default) {
    return schema.default;
  }
  if (schema.nullable) {
    return null;
  }
  if (optional) {
    return void 0;
  }
  if ((_a = schema.anyOf) == null ? void 0 : _a.length) {
    return getDefaultValues(schema.anyOf[0]);
  }
  if (schema.type === "object") {
    if (schema.properties) {
      const data = {};
      Object.entries(schema.properties).map(([key, fieldSchema]) => {
        var _a2;
        data[key] = getDefaultValues(fieldSchema, !((_a2 = schema.required) == null ? void 0 : _a2.includes(key)) || isOptional(fieldSchema) || false);
      });
      return data;
    }
  }
  if (schema.type === "array") {
    if (schema.minItems && schema.minItems > 0) {
      return [getDefaultValues(schema.items)];
    }
    return [];
  }
  if (schema.type === "string") {
    if ((_b = schema.enum) == null ? void 0 : _b.length) {
      return schema.enum[0];
    }
    return "";
  }
  if (schema.type === "number") {
    if ((_c = schema.enum) == null ? void 0 : _c.length) {
      return schema.enum[0];
    }
    return 0;
  }
  if (schema.type === "boolean") {
    if ((_d = schema.enum) == null ? void 0 : _d.length) {
      return schema.enum[0];
    }
    return false;
  }
  return void 0;
}, "getDefaultValues");
var FormDataProvider = /* @__PURE__ */ __name(({
  children,
  setFormData,
  formData,
  formSchema,
  disableValidation,
  onValidation,
  dataTransform
}) => {
  const [hiddenState, setHiddenState] = (0, import_react.useState)({});
  const [disabledState, setDisabledState] = (0, import_react.useState)({});
  const transformedData = dataTransform ? dataTransform(formData) : formData;
  const validation = (0, import_react.useMemo)(() => {
    if (disableValidation) {
      return { formValid: null, formErrors: null };
    }
    if (!formSchema) {
      return { formValid: null, formErrors: null };
    }
    const validation2 = jsonSchemaToZui(formSchema).safeParse(transformedData);
    if (!validation2.success) {
      return {
        formValid: false,
        formErrors: validation2.error.issues
      };
    }
    return {
      formValid: true,
      formErrors: []
    };
  }, [JSON.stringify({ transformedData })]);
  (0, import_react.useEffect)(() => {
    if (onValidation) {
      onValidation(validation);
    }
  }, [validation]);
  return /* @__PURE__ */ import_react.default.createElement(
    FormDataContext.Provider,
    {
      value: {
        formData,
        setFormData,
        formSchema,
        validation,
        hiddenState,
        setHiddenState,
        disabledState,
        setDisabledState,
        dataTransform
      }
    },
    children
  );
}, "FormDataProvider");
function getPathData(object, path) {
  return path.reduce((prev, curr) => {
    return prev ? prev[curr] : null;
  }, object);
}
__name(getPathData, "getPathData");
function isOptional(schema) {
  var _a;
  return ((_a = schema.anyOf) == null ? void 0 : _a.some((s) => s.not && Object.keys(s.not).length === 0)) || false;
}
__name(isOptional, "isOptional");
function deepMerge(target, source) {
  const output4 = __spreadValues({}, target);
  for (const key in source) {
    if (source.hasOwnProperty(key)) {
      if (typeof source[key] === "object" && source[key] !== null && !Array.isArray(source[key])) {
        if (typeof output4[key] === "object" && output4[key] !== null && !Array.isArray(output4[key])) {
          output4[key] = deepMerge(output4[key], source[key]);
        } else {
          output4[key] = deepMerge({}, source[key]);
        }
      } else {
        output4[key] = source[key];
      }
    }
  }
  return output4;
}
__name(deepMerge, "deepMerge");

// src/ui/hooks/useDiscriminator.ts
var useDiscriminator = /* @__PURE__ */ __name((fieldSchema, path) => {
  const { handlePropertyChange, data } = useFormData(fieldSchema, path);
  const { discriminator, value, discriminatedSchema } = (0, import_react2.useMemo)(() => {
    const discriminator2 = resolveDiscriminator(fieldSchema.anyOf);
    const value2 = (discriminator2 == null ? void 0 : discriminator2.key) ? data == null ? void 0 : data[discriminator2.key] : fieldSchema.default || null;
    const discriminatedSchema2 = resolveDiscriminatedSchema((discriminator2 == null ? void 0 : discriminator2.key) || null, value2, fieldSchema.anyOf);
    return {
      discriminator: discriminator2,
      value: value2,
      discriminatedSchema: discriminatedSchema2
    };
  }, [fieldSchema.anyOf, data]);
  (0, import_react2.useEffect)(() => {
    if ((discriminator == null ? void 0 : discriminator.key) && (discriminator == null ? void 0 : discriminator.values.length) && Object.keys(data || {}).length < 1 && !fieldSchema.default) {
      handlePropertyChange(path, { [discriminator.key]: discriminator.values[0] });
    }
  }, []);
  return { discriminator, discriminatorValue: value, discriminatedSchema };
}, "useDiscriminator");
var resolveDiscriminator = /* @__PURE__ */ __name((anyOf) => {
  const output4 = anyOf == null ? void 0 : anyOf.map((schema) => {
    if (schema.type !== "object") {
      return null;
    }
    if (!schema.properties) {
      return null;
    }
    return Object.entries(schema.properties).map(([key, def]) => {
      var _a;
      if (def.type === "string" && ((_a = def.enum) == null ? void 0 : _a.length)) {
        return { key, value: def.enum[0] };
      }
      return null;
    }).filter((v) => !!v);
  }).flat().reduce(
    (acc, data) => {
      if (!data) {
        return acc;
      }
      const { key, value } = data;
      if (acc.key === null) {
        acc.key = key;
      }
      if (acc.key === key) {
        acc.values.push(value);
      }
      return acc;
    },
    { key: null, values: [] }
  );
  if ((output4 == null ? void 0 : output4.key) === null || !(output4 == null ? void 0 : output4.values.length)) {
    return null;
  }
  return output4;
}, "resolveDiscriminator");
var resolveDiscriminatedSchema = /* @__PURE__ */ __name((key, value, anyOf) => {
  var _a, _b;
  if (!(anyOf == null ? void 0 : anyOf.length) || !key || !value) {
    return null;
  }
  for (const schema of anyOf) {
    if (schema.type !== "object") {
      continue;
    }
    const discriminator = (_a = schema.properties) == null ? void 0 : _a[key];
    if ((discriminator == null ? void 0 : discriminator.type) === "string" && ((_b = discriminator.enum) == null ? void 0 : _b.length) && discriminator.enum[0] === value) {
      return __spreadProps(__spreadValues({}, schema), {
        properties: __spreadProps(__spreadValues({}, schema.properties), {
          [key]: __spreadProps(__spreadValues({}, discriminator), { [zuiKey]: { hidden: true } })
        })
      });
    }
  }
  return null;
}, "resolveDiscriminatedSchema");

// src/ui/utils.ts
var getSchemaType = /* @__PURE__ */ __name((schema) => {
  var _a;
  if ((_a = schema.anyOf) == null ? void 0 : _a.length) {
    const discriminator = resolveDiscriminator(schema.anyOf);
    return discriminator ? "discriminatedUnion" : "object";
  }
  if (schema.type === "integer") {
    return "number";
  }
  return schema.type;
}, "getSchemaType");
var resolveComponent = /* @__PURE__ */ __name((components, fieldSchema) => {
  var _a, _b, _c;
  const type = getSchemaType(fieldSchema);
  const uiDefinition = ((_a = fieldSchema[zuiKey]) == null ? void 0 : _a.displayAs) || null;
  if (!uiDefinition || !Array.isArray(uiDefinition) || uiDefinition.length < 2) {
    const defaultComponent = (_b = components == null ? void 0 : components[type]) == null ? void 0 : _b.default;
    if (!defaultComponent) {
      return null;
    }
    return {
      Component: defaultComponent,
      type,
      id: "default",
      params: {}
    };
  }
  const componentID = uiDefinition[0];
  const Component2 = ((_c = components == null ? void 0 : components[type]) == null ? void 0 : _c[componentID]) || null;
  if (!Component2) {
    console.warn(`Component ${type}.${componentID} not found`);
    return null;
  }
  const params = uiDefinition[1] || {};
  return {
    Component: Component2,
    type,
    id: componentID,
    params
  };
}, "resolveComponent");
function pathMatches(path1, path2) {
  if (path1.length !== path2.length)
    return false;
  return path1.every((part, index) => part === path2[index]);
}
__name(pathMatches, "pathMatches");
function formatTitle(title, separator) {
  if (!separator)
    separator = new RegExp("/s|-|_| ", "g");
  return decamelize(title).split(separator).map(capitalize).map(handleSpecialWords).reduce(combine);
}
__name(formatTitle, "formatTitle");
function capitalize(word) {
  return word.charAt(0).toUpperCase() + word.substring(1);
}
__name(capitalize, "capitalize");
function combine(acc, text) {
  return `${acc} ${text}`;
}
__name(combine, "combine");
function decamelize(text) {
  return text.replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1_$2").toLowerCase();
}
__name(decamelize, "decamelize");
function handleSpecialWords(text, index, words) {
  const lowercaseStr = text.toLowerCase();
  const uppercaseStr = text.toUpperCase();
  for (const special of specialCase) {
    if (special.toLowerCase() === lowercaseStr)
      return special;
  }
  if (acronyms.includes(uppercaseStr))
    return uppercaseStr;
  if (index === 0)
    return text;
  if (index === words.length - 1)
    return text;
  if (text.length >= 4)
    return text;
  if (prepositions.includes(lowercaseStr))
    return lowercaseStr;
  if (conjunctions.includes(lowercaseStr))
    return lowercaseStr;
  if (articles.includes(lowercaseStr))
    return lowercaseStr;
  return text;
}
__name(handleSpecialWords, "handleSpecialWords");
var acronyms = [
  "2D",
  "3D",
  "4WD",
  "A2O",
  "API",
  "BIOS",
  "CCTV",
  "CC",
  "CCV",
  "CD",
  "CD-ROM",
  "COBOL",
  "CIA",
  "CMS",
  "CSS",
  "CSV",
  "CV",
  "DIY",
  "DVD",
  "DB",
  "DNA",
  "E3",
  "EIN",
  "ESPN",
  "FAQ",
  "FAQs",
  "FTP",
  "FPS",
  "FORTRAN",
  "FBI",
  "HTML",
  "HTTP",
  "ID",
  "IP",
  "ISO",
  "JS",
  "JSON",
  "LASER",
  "M2A",
  "M2M",
  "M2MM",
  "M2O",
  "MMORPG",
  "NAFTA",
  "NASA",
  "NDA",
  "O2M",
  "PDF",
  "PHP",
  "POP",
  "RAM",
  "RNGR",
  "ROM",
  "RPG",
  "RTFM",
  "RTS",
  "SCUBA",
  "SITCOM",
  "SKU",
  "SMTP",
  "SQL",
  "SSN",
  "SWAT",
  "TBS",
  "TTL",
  "TV",
  "TNA",
  "UI",
  "URL",
  "USB",
  "UWP",
  "VIP",
  "W3C",
  "WYSIWYG",
  "WWW",
  "WWE",
  "WWF"
];
var articles = ["a", "an", "the"];
var conjunctions = [
  "and",
  "that",
  "but",
  "or",
  "as",
  "if",
  "when",
  "than",
  "because",
  "while",
  "where",
  "after",
  "so",
  "though",
  "since",
  "until",
  "whether",
  "before",
  "although",
  "nor",
  "like",
  "once",
  "unless",
  "now",
  "except"
];
var prepositions = [
  "about",
  "above",
  "across",
  "after",
  "against",
  "along",
  "among",
  "around",
  "at",
  "because of",
  "before",
  "behind",
  "below",
  "beneath",
  "beside",
  "besides",
  "between",
  "beyond",
  "but",
  "by",
  "concerning",
  "despite",
  "down",
  "during",
  "except",
  "excepting",
  "for",
  "from",
  "in",
  "in front of",
  "inside",
  "in spite of",
  "instead of",
  "into",
  "like",
  "near",
  "of",
  "off",
  "on",
  "onto",
  "out",
  "outside",
  "over",
  "past",
  "regarding",
  "since",
  "through",
  "throughout",
  "to",
  "toward",
  "under",
  "underneath",
  "until",
  "up",
  "upon",
  "up to",
  "with",
  "within",
  "without",
  "with regard to",
  "with respect to"
];
var specialCase = [
  "2FA",
  "3D",
  "4K",
  "5K",
  "8K",
  "AGI",
  "BI",
  "ChatGPT",
  "CTA",
  "DateTime",
  "GitHub",
  "GPT",
  "HD",
  "IBMid",
  "ID",
  "IDs",
  "iMac",
  "IMAX",
  "iOS",
  "IP",
  "iPad",
  "iPhone",
  "iPod",
  "LDAP",
  "LinkedIn",
  "LLM",
  "M2M",
  "M2O",
  "macOS",
  "McDonalds",
  "ML",
  "MySQL",
  "NLG",
  "NLP",
  "NLU",
  "O2M",
  "OpenAI",
  "PDFs",
  "PEFT",
  "pH",
  "PostgreSQL",
  "SEO",
  "TTS",
  "UHD",
  "UUID",
  "XSS",
  "YouTube"
];

// src/transforms/zui-to-typescript-type/utils.ts
function escapeString(str) {
  if (typeof str !== "string") {
    return "";
  }
  const rawStr = String.raw`${str}`;
  if (rawStr.includes("`")) {
    return `"${rawStr.replace(/"/g, '\\"')}"`;
  } else if (rawStr.includes("'")) {
    return `'${rawStr.replace(/'/g, "\\'")}'`;
  } else {
    return `'${rawStr}'`;
  }
}
__name(escapeString, "escapeString");
var toPropertyKey = /* @__PURE__ */ __name((key) => {
  if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key)) {
    return key;
  }
  return escapeString(key);
}, "toPropertyKey");
var capitalize2 = /* @__PURE__ */ __name((s) => s.charAt(0).toUpperCase() + s.slice(1), "capitalize");
var toTypeArgumentName = /* @__PURE__ */ __name((name) => {
  const nonAlphaNumeric = /[^a-zA-Z0-9_]/g;
  const tokens = name.split(nonAlphaNumeric).map(capitalize2).filter((t) => !!t);
  return tokens.join("");
}, "toTypeArgumentName");
var getMultilineComment = /* @__PURE__ */ __name((description) => {
  const descLines = (description != null ? description : "").split("\n").filter((l) => l.trim().length > 0);
  return descLines.length === 0 ? "" : descLines.length === 1 ? `/** ${descLines[0]} */` : `/**
 * ${descLines.join("\n * ")}
 */`;
}, "getMultilineComment");

// src/transforms/zui-to-typescript-type/index.ts
var Primitives = [
  "string",
  "number",
  "boolean",
  "unknown",
  "void",
  "any",
  "null",
  "undefined",
  "never",
  "bigint",
  "symbol",
  "object"
];
var _ZuiToTypescriptError = class _ZuiToTypescriptError extends Error {
};
__name(_ZuiToTypescriptError, "ZuiToTypescriptError");
var ZuiToTypescriptError = _ZuiToTypescriptError;
var _UntitledDeclarationError = class _UntitledDeclarationError extends ZuiToTypescriptError {
  constructor(message2) {
    super(message2);
    this.name = "UntitledDeclarationError";
  }
  static isUntitledDeclarationError(err) {
    return err.name === "UntitledDeclarationError";
  }
};
__name(_UntitledDeclarationError, "UntitledDeclarationError");
var UntitledDeclarationError = _UntitledDeclarationError;
var _UnrepresentableGenericError = class _UnrepresentableGenericError extends ZuiToTypescriptError {
  constructor(message2) {
    super(message2);
    this.name = "UnrepresentableGenericError";
  }
  static isUnrepresentableGenericError(err) {
    return err.name === "UnrepresentableGenericError";
  }
};
__name(_UnrepresentableGenericError, "UnrepresentableGenericError");
var UnrepresentableGenericError = _UnrepresentableGenericError;
var isPrimitive = /* @__PURE__ */ __name((type) => Primitives.includes(type), "isPrimitive");
var isArrayOfPrimitives = /* @__PURE__ */ __name((type) => Primitives.map((p) => `${p}[]`).includes(type), "isArrayOfPrimitives");
var stripSpaces = /* @__PURE__ */ __name((typings) => typings.replace(/ +/g, " ").trim(), "stripSpaces");
var _KeyValue = class _KeyValue {
  constructor(key, value, optional = false) {
    this.key = key;
    this.value = value;
    this.optional = optional;
  }
};
__name(_KeyValue, "KeyValue");
var KeyValue = _KeyValue;
var _FnParameters = class _FnParameters {
  constructor(schema) {
    this.schema = schema;
  }
};
__name(_FnParameters, "FnParameters");
var FnParameters = _FnParameters;
var _FnReturn = class _FnReturn {
  constructor(schema) {
    this.schema = schema;
  }
};
__name(_FnReturn, "FnReturn");
var FnReturn = _FnReturn;
var _Declaration = class _Declaration {
  constructor(props) {
    this.props = props;
  }
};
__name(_Declaration, "Declaration");
var Declaration = _Declaration;
function toTypescript(schema, options = {}) {
  const wrappedSchema = getDeclarationProps(schema, options);
  let dts = sUnwrapZod(wrappedSchema, {});
  if (options.formatter) {
    dts = options.formatter(dts);
  }
  return dts;
}
__name(toTypescript, "toTypescript");
function sUnwrapZod(schema, config) {
  var _a, _b, _c;
  const newConfig = __spreadProps(__spreadValues({}, config), {
    parent: schema
  });
  if (schema === null) {
    return "";
  }
  if (schema instanceof Declaration) {
    return unwrapDeclaration(schema, newConfig);
  }
  if (schema instanceof KeyValue) {
    if (schema.value instanceof z_default.ZodOptional) {
      let innerType = schema.value._def.innerType;
      if (innerType instanceof z_default.Schema && !innerType.description && schema.value.description) {
        innerType = innerType == null ? void 0 : innerType.describe(schema.value.description);
      }
      return sUnwrapZod(new KeyValue(schema.key, innerType, true), newConfig);
    }
    const description = getMultilineComment(schema.value._def.description);
    const delimiter = (description == null ? void 0 : description.trim().length) > 0 ? "\n" : "";
    const withoutDesc = schema.value.describe("");
    const isOptional2 = schema.optional || schema.value.isOptional();
    const optionalModifier = isOptional2 ? "?" : "";
    return `${delimiter}${description}${delimiter}${schema.key}${optionalModifier}: ${sUnwrapZod(withoutDesc, newConfig)}${delimiter}`;
  }
  if (schema instanceof FnParameters) {
    if (schema.schema instanceof z_default.ZodTuple) {
      let args = "";
      for (let i = 0; i < schema.schema.items.length; i++) {
        const argName = (_c = (_b = (_a = schema.schema.items[i]) == null ? void 0 : _a.ui) == null ? void 0 : _b.title) != null ? _c : `arg${i}`;
        const item = schema.schema.items[i];
        args += `${sUnwrapZod(new KeyValue(toPropertyKey(argName), item), newConfig)}${i < schema.schema.items.length - 1 ? ", " : ""} `;
      }
      return args;
    }
    const typings = sUnwrapZod(schema.schema, newConfig);
    const startsWithPairs = typings.startsWith("{") && typings.endsWith("}") || typings.startsWith("[") && typings.endsWith("]") || typings.startsWith("(") && typings.endsWith(")") || typings.startsWith("Array<") && typings.endsWith(">") || typings.startsWith("Record<") && typings.endsWith(">") || isArrayOfPrimitives(typings);
    if (startsWithPairs) {
      return `args: ${typings}`;
    } else {
      return typings;
    }
  }
  if (schema instanceof FnReturn) {
    if (schema.schema instanceof z_default.ZodOptional) {
      return `${sUnwrapZod(schema.schema.unwrap(), newConfig)} | undefined`;
    }
    return sUnwrapZod(schema.schema, newConfig);
  }
  const schemaTyped = schema;
  const def = schemaTyped._def;
  switch (def.typeName) {
    case z_default.ZodFirstPartyTypeKind.ZodString:
      return `${getMultilineComment(def.description)} string`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNumber:
    case z_default.ZodFirstPartyTypeKind.ZodNaN:
    case z_default.ZodFirstPartyTypeKind.ZodBigInt:
      return `${getMultilineComment(def.description)} number`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodBoolean:
      return `${getMultilineComment(schema._def.description)} boolean`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodDate:
      return `${getMultilineComment(def.description)} Date`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodUndefined:
      return `${getMultilineComment(def.description)} undefined`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNull:
      return `${getMultilineComment(def.description)} null`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodAny:
      return `${getMultilineComment(def.description)} any`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodUnknown:
      return `${getMultilineComment(def.description)} unknown`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNever:
      return `${getMultilineComment(def.description)} never`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodVoid:
      return `${getMultilineComment(def.description)} void`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodArray:
      const item = sUnwrapZod(def.type, newConfig);
      if (isPrimitive(item)) {
        return `${item}[]`;
      }
      return `Array<${item}>`;
    case z_default.ZodFirstPartyTypeKind.ZodObject:
      const props = Object.entries(def.shape()).map(([key, value2]) => {
        if (value2 instanceof z_default.Schema) {
          return sUnwrapZod(new KeyValue(toPropertyKey(key), value2), newConfig);
        }
        return `${key}: unknown`;
      });
      return `{ ${props.join("; ")} }`;
    case z_default.ZodFirstPartyTypeKind.ZodUnion:
      const options = def.options.map((option) => {
        return sUnwrapZod(option, newConfig);
      });
      return `${getMultilineComment(def.description)}
${options.join(" | ")}`;
    case z_default.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      const opts = def.options.map((option) => {
        return sUnwrapZod(option, newConfig);
      });
      return `${getMultilineComment(schema._def.description)}
${opts.join(" | ")}`;
    case z_default.ZodFirstPartyTypeKind.ZodIntersection:
      return `${sUnwrapZod(def.left, newConfig)} & ${sUnwrapZod(def.right, newConfig)}`;
    case z_default.ZodFirstPartyTypeKind.ZodTuple:
      if (def.items.length === 0) {
        return "";
      }
      const items = def.items.map((i) => sUnwrapZod(i, newConfig));
      return `[${items.join(", ")}]`;
    case z_default.ZodFirstPartyTypeKind.ZodRecord:
      const keyType = sUnwrapZod(def.keyType, newConfig);
      const valueType = sUnwrapZod(def.valueType, newConfig);
      return `${getMultilineComment(def.description)} { [key: ${keyType}]: ${valueType} }`;
    case z_default.ZodFirstPartyTypeKind.ZodMap:
      return `Map<${sUnwrapZod(def.keyType, newConfig)}, ${sUnwrapZod(def.valueType, newConfig)}>`;
    case z_default.ZodFirstPartyTypeKind.ZodSet:
      return `Set<${sUnwrapZod(def.valueType, newConfig)}>`;
    case z_default.ZodFirstPartyTypeKind.ZodFunction:
      const input4 = sUnwrapZod(new FnParameters(def.args), newConfig);
      const output4 = sUnwrapZod(new FnReturn(def.returns), newConfig);
      return `${getMultilineComment(def.description)}
(${input4}) => ${output4}`;
    case z_default.ZodFirstPartyTypeKind.ZodLazy:
      return sUnwrapZod(def.getter(), newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodLiteral:
      if (typeof def.value === "bigint") {
        throw new Error("BigInt literals are not supported yet");
      }
      const value = typeof def.value === "string" ? escapeString(def.value) : String(def.value);
      return `${getMultilineComment(def.description)}
${value}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodEnum:
      const values = def.values.map(escapeString);
      return values.join(" | ");
    case z_default.ZodFirstPartyTypeKind.ZodEffects:
      return sUnwrapZod(def.schema, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodNativeEnum:
      throw new Error("ZodNativeEnum cannot be transformed to TypeScript type yet");
    case z_default.ZodFirstPartyTypeKind.ZodOptional:
      return `${sUnwrapZod(def.innerType, newConfig)} | undefined`;
    case z_default.ZodFirstPartyTypeKind.ZodNullable:
      return `${sUnwrapZod(def.innerType, newConfig)} | null`;
    case z_default.ZodFirstPartyTypeKind.ZodDefault:
      return sUnwrapZod(def.innerType, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodCatch:
      return sUnwrapZod(def.innerType, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodPromise:
      return `Promise<${sUnwrapZod(def.type, newConfig)}>`;
    case z_default.ZodFirstPartyTypeKind.ZodBranded:
      return sUnwrapZod(def.type, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodPipeline:
      return sUnwrapZod(def.in, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodSymbol:
      return `${getMultilineComment(def.description)} symbol`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodReadonly:
      return `readonly ${sUnwrapZod(def.innerType, newConfig)}`;
    case z_default.ZodFirstPartyTypeKind.ZodRef:
      return toTypeArgumentName(def.uri);
    case z_default.ZodFirstPartyTypeKind.ZodTemplateLiteral:
      const inner = def.parts.map((p) => {
        if (typeof p === "undefined" || p === null) {
          return "";
        }
        if (typeof p === "string") {
          return p;
        }
        if (typeof p === "boolean" || typeof p === "number") {
          return `${p}`;
        }
        return "${" + sUnwrapZod(p, __spreadValues({}, newConfig)) + "}";
      }).join("");
      return `\`${inner}\``;
    default:
      util.assertNever(def);
  }
}
__name(sUnwrapZod, "sUnwrapZod");
var unwrapDeclaration = /* @__PURE__ */ __name((declaration, options) => {
  if (declaration.props.type === "none") {
    return sUnwrapZod(declaration.props.schema, options);
  }
  const description = getMultilineComment(declaration.props.schema.description);
  const withoutDesc = declaration.props.schema.describe("");
  const typings = sUnwrapZod(withoutDesc, options);
  if (declaration.props.type === "variable") {
    return stripSpaces(`${description}declare const ${declaration.props.identifier}: ${typings};`);
  }
  const generics = declaration.props.args.length > 0 ? `<${declaration.props.args.map(toTypeArgumentName).join(", ")}>` : "";
  return stripSpaces(`${description}type ${declaration.props.identifier}${generics} = ${typings};`);
}, "unwrapDeclaration");
var getDeclarationType = /* @__PURE__ */ __name((options) => {
  if (!options.declaration) {
    return "none";
  }
  if (options.declaration === true) {
    return "variable";
  }
  return options.declaration;
}, "getDeclarationType");
var getDeclarationProps = /* @__PURE__ */ __name((schema, options) => {
  const declarationType = getDeclarationType(options);
  const args = schema.getReferences();
  if (declarationType === "none") {
    if (args.length > 0) {
      throw new UnrepresentableGenericError(
        'ZodRefs are only supported when generating "type" declaration. Please set "declaration" option to "type".'
      );
    }
    return new Declaration({ type: "none", schema });
  }
  const title = "title" in schema.ui ? schema.ui.title : null;
  if (!title) {
    throw new UntitledDeclarationError('Only schemas with "title" Zui property can be declared.');
  }
  if (declarationType === "variable") {
    if (args.length > 0) {
      throw new UnrepresentableGenericError(
        'ZodRefs are only supported when generating "type" declaration. Please set "declaration" option to "type".'
      );
    }
    return new Declaration({ type: "variable", identifier: title, schema });
  }
  return new Declaration({ type: "type", identifier: title, schema, args });
}, "getDeclarationProps");

// src/transforms/zui-to-typescript-schema/utils.ts
var toTypesriptPrimitive = /* @__PURE__ */ __name((primitive) => {
  if (typeof primitive === "string") {
    return escapeString(primitive);
  }
  return String(primitive);
}, "toTypesriptPrimitive");
var mapValues = /* @__PURE__ */ __name((map, fn) => {
  const result = {};
  for (const key in map) {
    result[key] = fn(map[key], key);
  }
  return result;
}, "mapValues");

// src/transforms/zui-to-typescript-schema/index.ts
function toTypescriptSchema(schema, _options) {
  let wrappedSchema = schema;
  let dts = sUnwrapZod2(wrappedSchema);
  return dts;
}
__name(toTypescriptSchema, "toTypescriptSchema");
function sUnwrapZod2(schema) {
  const schemaTyped = schema;
  const def = schemaTyped._def;
  switch (def.typeName) {
    case z_default.ZodFirstPartyTypeKind.ZodString:
      return `${getMultilineComment(def.description)}z.string()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNumber:
      return `${getMultilineComment(def.description)}z.number()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNaN:
      return `${getMultilineComment(def.description)}z.nan()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodBigInt:
      return `${getMultilineComment(def.description)}z.bigint()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodBoolean:
      return `${getMultilineComment(schema._def.description)}z.boolean()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodDate:
      return `${getMultilineComment(def.description)}z.date()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodUndefined:
      return `${getMultilineComment(def.description)}z.undefined()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNull:
      return `${getMultilineComment(def.description)}z.null()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodAny:
      return `${getMultilineComment(def.description)}z.any()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodUnknown:
      return `${getMultilineComment(def.description)}z.unknown()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNever:
      return `${getMultilineComment(def.description)}z.never()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodVoid:
      return `${getMultilineComment(def.description)}z.void()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodArray:
      return `z.array(${sUnwrapZod2(def.type)})`;
    case z_default.ZodFirstPartyTypeKind.ZodObject:
      const props = mapValues(def.shape(), (value2) => {
        if (value2 instanceof z_default.Schema) {
          return sUnwrapZod2(value2);
        }
        return `z.any()`;
      });
      return [
        //
        `${getMultilineComment(def.description)}z.object({`,
        ...Object.entries(props).map(([key, value2]) => `  ${key}: ${value2},`),
        `})`
      ].join("\n").trim();
    case z_default.ZodFirstPartyTypeKind.ZodUnion:
      const options = def.options.map(sUnwrapZod2);
      return `${getMultilineComment(def.description)}z.union([${options.join(", ")}])`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      const opts = def.options.map(sUnwrapZod2);
      const discriminator = escapeString(def.discriminator);
      return `${getMultilineComment(def.description)}z.discriminatedUnion(${discriminator}, [${opts.join(", ")}])`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodIntersection:
      const left = sUnwrapZod2(def.left);
      const right = sUnwrapZod2(def.right);
      return `${getMultilineComment(def.description)}z.intersection(${left}, ${right})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodTuple:
      const items = def.items.map(sUnwrapZod2);
      return `${getMultilineComment(def.description)}z.tuple([${items.join(", ")}])`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodRecord:
      const keyType = sUnwrapZod2(def.keyType);
      const valueType = sUnwrapZod2(def.valueType);
      return `${getMultilineComment(def.description)}z.record(${keyType}, ${valueType})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodMap:
      const mapKeyType = sUnwrapZod2(def.keyType);
      const mapValueType = sUnwrapZod2(def.valueType);
      return `${getMultilineComment(def.description)}z.map(${mapKeyType}, ${mapValueType})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodSet:
      return `${getMultilineComment(def.description)}z.set(${sUnwrapZod2(def.valueType)})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodFunction:
      const args = def.args.items.map(sUnwrapZod2);
      const argsString = args.length ? `.args(${args.join(", ")})` : "";
      const returns = sUnwrapZod2(def.returns);
      return `${getMultilineComment(def.description)}z.function()${argsString}.returns(${returns})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodLazy:
      return `${getMultilineComment(def.description)}z.lazy(() => ${sUnwrapZod2(def.getter())})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodLiteral:
      const value = toTypesriptPrimitive(def.value);
      return `${getMultilineComment(def.description)}z.literal(${value})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodEnum:
      const values = def.values.map(toTypesriptPrimitive);
      return `${getMultilineComment(def.description)}z.enum([${values.join(", ")}])`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodEffects:
      throw new Error("ZodEffects cannot be transformed to TypeScript expression yet");
    case z_default.ZodFirstPartyTypeKind.ZodNativeEnum:
      throw new Error("ZodNativeEnum cannot be transformed to TypeScript expression yet");
    case z_default.ZodFirstPartyTypeKind.ZodOptional:
      return `${getMultilineComment(def.description)}z.optional(${sUnwrapZod2(def.innerType)})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNullable:
      return `${getMultilineComment(def.description)}z.nullable(${sUnwrapZod2(def.innerType)})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodDefault:
      const defaultValue = toTypesriptPrimitive(def.defaultValue());
      return `${getMultilineComment(def.description)}${sUnwrapZod2(def.innerType)}.default(${defaultValue})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodCatch:
      const catchValue = toTypesriptPrimitive(def.catchValue({ error: new ZodError([]), input: null }));
      return `${getMultilineComment(def.description)}${sUnwrapZod2(def.innerType)}.catch(${catchValue})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodPromise:
      return `${getMultilineComment(def.description)}z.promise(${sUnwrapZod2(def.type)})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodBranded:
      throw new Error("ZodBranded cannot be transformed to TypeScript expression yet");
    case z_default.ZodFirstPartyTypeKind.ZodPipeline:
      throw new Error("ZodPipeline cannot be transformed to TypeScript expression yet");
    case z_default.ZodFirstPartyTypeKind.ZodSymbol:
      throw new Error("ZodSymbol cannot be transformed to TypeScript expression yet");
    case z_default.ZodFirstPartyTypeKind.ZodReadonly:
      return `${getMultilineComment(def.description)}z.readonly(${sUnwrapZod2(def.innerType)})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodRef:
      const uri = escapeString(def.uri);
      return `${getMultilineComment(def.description)}z.ref(${uri})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodTemplateLiteral:
      throw new Error("ZodTemplateLiteral cannot be transformed to TypeScript expression yet");
    default:
      util.assertNever(def);
  }
}
__name(sUnwrapZod2, "sUnwrapZod");

// src/z/types/basetype/index.ts
var _ParseInputLazyPath = class _ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
__name(_ParseInputLazyPath, "ParseInputLazyPath");
var ParseInputLazyPath = _ParseInputLazyPath;
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, "handleResult");
var _ZodType = class _ZodType {
  constructor(def) {
    /** Alias of safeParseAsync */
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  /** deeply replace all references in the schema */
  dereference(_defs) {
    return this;
  }
  /** deeply scans the schema to check if it contains references */
  getReferences() {
    return [];
  }
  _getType(input4) {
    return getParsedType(input4.data);
  }
  _getOrReturnCtx(input4, ctx) {
    return ctx || {
      common: input4.parent.common,
      data: input4.data,
      parsedType: getParsedType(input4.data),
      schemaErrorMap: this._def.errorMap,
      path: input4.path,
      parent: input4.parent
    };
  }
  _processInputParams(input4) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input4.parent.common,
        data: input4.data,
        parsedType: getParsedType(input4.data),
        schemaErrorMap: this._def.errorMap,
        path: input4.path,
        parent: input4.parent
      }
    };
  }
  _parseSync(input4) {
    const result = this._parse(input4);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input4) {
    const result = this._parse(input4);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params == null ? void 0 : params.async) != null ? _a : false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message2) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message2 === "string" || typeof message2 === "undefined") {
        return { message: message2 };
      } else if (typeof message2 === "function") {
        return message2(val);
      } else {
        return message2;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue(__spreadValues({
        code: ZodIssueCode.custom
      }, getIssueProperties(val))), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: "ZodEffects" /* ZodEffects */,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      schema: this,
      typeName: "ZodEffects" /* ZodEffects */,
      effect: { type: "transform", transform }
    }));
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: "ZodDefault" /* ZodDefault */
    }));
  }
  brand() {
    return new ZodBranded(__spreadValues({
      typeName: "ZodBranded" /* ZodBranded */,
      type: this
    }, processCreateParams(this._def)));
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      innerType: this,
      catchValue: catchValueFunc,
      typeName: "ZodCatch" /* ZodCatch */
    }));
  }
  describe(description) {
    const This = this.constructor;
    return new This(__spreadProps(__spreadValues({}, this._def), {
      description
    }));
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
  // BOTPRESS EXTENSIONS
  /** append metadata to object */
  metadata(data) {
    for (const [key, value] of Object.entries(data)) {
      this._def[zuiKey] = __spreadProps(__spreadValues({}, this._def[zuiKey]), {
        [key]: value
      });
    }
    return this;
  }
  /** get metadata of object */
  getMetadata() {
    return __spreadValues({}, this._def[zuiKey]);
  }
  /** set metadata of object */
  setMetadata(data) {
    this._def[zuiKey] = __spreadValues({}, data);
  }
  /**
   * @deprecated use `getMetadata` instead
   */
  get ui() {
    const root = this._getMetadataRoot();
    return __spreadValues({}, root._def[zuiKey]);
  }
  _setZuiMeta(key, value) {
    const root = this._getMetadataRoot();
    root._def[zuiKey] = __spreadProps(__spreadValues({}, root._def[zuiKey]), {
      [key]: value
    });
  }
  _getMetadataRoot() {
    const def = this._def;
    switch (def.typeName) {
      case "ZodNullable" /* ZodNullable */:
      case "ZodDefault" /* ZodDefault */:
      case "ZodOptional" /* ZodOptional */:
      case "ZodReadonly" /* ZodReadonly */:
        return def.innerType;
      case "ZodEffects" /* ZodEffects */:
        return def.schema;
      default:
        return this;
    }
  }
  /**
   * The type of component to use to display the field and its options
   */
  displayAs(options) {
    var _a, _b, _c;
    (_c = (_a = this._def)[_b = zuiKey]) != null ? _c : _a[_b] = {};
    this._def[zuiKey].displayAs = [options.id, options.params];
    return this;
  }
  /**
   * The title of the field. Defaults to the field name.
   */
  title(title) {
    this._setZuiMeta("title", title);
    return this;
  }
  /**
   * Whether the field is hidden in the UI. Useful for internal fields.
   * @default false
   */
  hidden(value) {
    let data;
    if (value === void 0) {
      data = true;
    } else if (typeof value === "function") {
      data = value.toString();
    } else {
      data = value;
    }
    this._setZuiMeta("hidden", data);
    return this;
  }
  /**
   * Whether the field is disabled
   * @default false
   */
  disabled(value) {
    let data;
    if (value === void 0) {
      data = true;
    } else if (typeof value === "function") {
      data = value.toString();
    } else {
      data = value;
    }
    this._setZuiMeta("disabled", data);
    return this;
  }
  /**
   * Placeholder text for the field
   */
  placeholder(placeholder) {
    this._setZuiMeta("placeholder", placeholder);
    return this;
  }
  toJsonSchema(opts) {
    return zuiToJsonSchema(this, opts);
  }
  /**
   *
   * @param options generation options
   * @returns a string of the TypeScript type representing the schema
   */
  toTypescript(opts) {
    return toTypescript(this, opts);
  }
  /**
   *
   * @param options generation options
   * @returns a typescript program (a string) that would construct the given schema if executed
   */
  toTypescriptSchema() {
    return toTypescriptSchema(this);
  }
  async toTypescriptAsync(opts) {
    let result = toTypescript(this, __spreadProps(__spreadValues({}, opts), { formatter: void 0 }));
    if (opts == null ? void 0 : opts.formatter) {
      result = await opts.formatter(result);
    }
    return result;
  }
  static fromObject(obj, opts) {
    return objectToZui(obj, opts);
  }
  static fromJsonSchema(schema) {
    return jsonSchemaToZui(schema);
  }
};
__name(_ZodType, "ZodType");
var ZodType = _ZodType;

// src/z/types/defs.ts
var ZodFirstPartyTypeKind = /* @__PURE__ */ ((ZodFirstPartyTypeKind4) => {
  ZodFirstPartyTypeKind4["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind4["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind4["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind4["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind4["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind4["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind4["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind4["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind4["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind4["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind4["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind4["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind4["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind4["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind4["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind4["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind4["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind4["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind4["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind4["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind4["ZodRef"] = "ZodRef";
  ZodFirstPartyTypeKind4["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind4["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind4["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind4["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind4["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind4["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind4["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind4["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind4["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind4["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind4["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind4["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind4["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind4["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind4["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind4["ZodTemplateLiteral"] = "ZodTemplateLiteral";
  ZodFirstPartyTypeKind4["ZodReadonly"] = "ZodReadonly";
  return ZodFirstPartyTypeKind4;
})(ZodFirstPartyTypeKind || {});

// src/z/types/utils/index.ts
var util;
((util4) => {
  util4.assertEqual = /* @__PURE__ */ __name((val) => val, "assertEqual");
  function assertIs(_arg) {
  }
  util4.assertIs = assertIs;
  __name(assertIs, "assertIs");
  function assertNever(_x) {
    throw new Error("assertNever called");
  }
  util4.assertNever = assertNever;
  __name(assertNever, "assertNever");
  util4.arrayToEnum = /* @__PURE__ */ __name((items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  }, "arrayToEnum");
  util4.getValidEnumValues = /* @__PURE__ */ __name((obj) => {
    const validKeys = (0, util4.objectKeys)(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return (0, util4.objectValues)(filtered);
  }, "getValidEnumValues");
  util4.objectValues = /* @__PURE__ */ __name((obj) => {
    return (0, util4.objectKeys)(obj).map(function(e) {
      return obj[e];
    });
  }, "objectValues");
  util4.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util4.find = /* @__PURE__ */ __name((arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  }, "find");
  util4.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util4.joinValues = joinValues;
  __name(joinValues, "joinValues");
  util4.jsonStringifyReplacer = /* @__PURE__ */ __name((_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  }, "jsonStringifyReplacer");
})(util || (util = {}));
var objectUtil;
((objectUtil3) => {
  objectUtil3.mergeShapes = /* @__PURE__ */ __name((first, second) => {
    return __spreadValues(__spreadValues({}, first), second);
  }, "mergeShapes");
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description, [zuiKey]: params == null ? void 0 : params[zuiKey] };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error != null ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error != null ? invalid_type_error : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description, [zuiKey]: params == null ? void 0 : params[zuiKey] };
}
__name(processCreateParams, "processCreateParams");

// src/z/types/error/locales/en.ts
var errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
  let message2;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message2 = "Required";
      } else {
        message2 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message2 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message2 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message2 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message2 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message2 = `Invalid ${issue.validation}`;
      } else {
        message2 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message2 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message2 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message2 = "Number must be finite";
      break;
    case ZodIssueCode.unresolved_reference:
      message2 = "Unresolved reference";
      break;
    default:
      message2 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message2 };
}, "errorMap");
var en_default = errorMap;

// src/z/types/error/index.ts
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite",
  "unresolved_reference"
]);
var quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var _ZodError = class _ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = /* @__PURE__ */ __name((sub) => {
      this.issues = [...this.issues, sub];
    }, "addIssue");
    this.addIssues = /* @__PURE__ */ __name((subs = []) => {
      this.issues = [...this.issues, ...subs];
    }, "addIssues");
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      ;
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          ;
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
__name(_ZodError, "ZodError");
_ZodError.create = /* @__PURE__ */ __name((issues) => {
  const error = new _ZodError(issues);
  return error;
}, "create");
var ZodError = _ZodError;
var _ZodTemplateLiteralUnsupportedTypeError = class _ZodTemplateLiteralUnsupportedTypeError extends Error {
  constructor() {
    super("Unsupported zod type!");
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      ;
      this.__proto__ = actualProto;
    }
    this.name = "ZodTemplateLiteralUnsupportedTypeError";
  }
};
__name(_ZodTemplateLiteralUnsupportedTypeError, "ZodTemplateLiteralUnsupportedTypeError");
var ZodTemplateLiteralUnsupportedTypeError = _ZodTemplateLiteralUnsupportedTypeError;
var _ZodTemplateLiteralUnsupportedCheckError = class _ZodTemplateLiteralUnsupportedCheckError extends Error {
  constructor(typeKind, check) {
    super(`${typeKind}'s "${check}" check is not supported in template literals!`);
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      ;
      this.__proto__ = actualProto;
    }
    this.name = "ZodTemplateLiteralUnsupportedCheckError";
  }
};
__name(_ZodTemplateLiteralUnsupportedCheckError, "ZodTemplateLiteralUnsupportedCheckError");
var ZodTemplateLiteralUnsupportedCheckError = _ZodTemplateLiteralUnsupportedCheckError;
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");

// src/z/types/utils/parseUtil.ts
var makeIssue = /* @__PURE__ */ __name((params) => {
  var _a;
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = __spreadProps(__spreadValues({}, issueData), {
    path: fullPath
  });
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return __spreadProps(__spreadValues({}, issueData), {
    path: fullPath,
    message: (_a = issueData.message) != null ? _a : errorMessage
  });
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      getErrorMap(),
      // then global override map
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
var _ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
__name(_ParseStatus, "ParseStatus");
var ParseStatus = _ParseStatus;
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");

// src/z/types/utils/errorUtil.ts
var errorUtil;
((errorUtil2) => {
  errorUtil2.errToObj = /* @__PURE__ */ __name((message2) => typeof message2 === "string" ? { message: message2 } : message2 || {}, "errToObj");
  errorUtil2.toString = /* @__PURE__ */ __name((message2) => typeof message2 === "string" ? message2 : message2 == null ? void 0 : message2.message, "toString");
})(errorUtil || (errorUtil = {}));

// src/z/types/any/index.ts
var _ZodAny = class _ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
    this._any = true;
  }
  _parse(input4) {
    return OK(input4.data);
  }
};
__name(_ZodAny, "ZodAny");
_ZodAny.create = /* @__PURE__ */ __name((params) => {
  return new _ZodAny(__spreadValues({
    typeName: "ZodAny" /* ZodAny */
  }, processCreateParams(params)));
}, "create");
var ZodAny = _ZodAny;

// src/z/types/array/index.ts
var _ZodArray = class _ZodArray extends ZodType {
  dereference(defs) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      type: this._def.type.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.type.getReferences();
  }
  _parse(input4) {
    const { ctx, status } = this._processInputParams(input4);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all(
        [...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })
      ).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message2) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      minLength: { value: minLength, message: errorUtil.toString(message2) }
    }));
  }
  max(maxLength, message2) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      maxLength: { value: maxLength, message: errorUtil.toString(message2) }
    }));
  }
  length(len, message2) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      exactLength: { value: len, message: errorUtil.toString(message2) }
    }));
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
__name(_ZodArray, "ZodArray");
_ZodArray.create = /* @__PURE__ */ __name((schema, params) => {
  return new _ZodArray(__spreadValues({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: "ZodArray" /* ZodArray */
  }, processCreateParams(params)));
}, "create");
var ZodArray = _ZodArray;

// src/z/types/bigint/index.ts
var _ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = BigInt(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input4.data < check.value : input4.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input4.data > check.value : input4.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input4.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input4.data };
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
__name(_ZodBigInt, "ZodBigInt");
_ZodBigInt.create = /* @__PURE__ */ __name((params) => {
  var _a;
  return new _ZodBigInt(__spreadValues({
    checks: [],
    typeName: "ZodBigInt" /* ZodBigInt */,
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false
  }, processCreateParams(params)));
}, "create");
var ZodBigInt = _ZodBigInt;

// src/z/types/boolean/index.ts
var _ZodBoolean = class _ZodBoolean extends ZodType {
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = Boolean(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
};
__name(_ZodBoolean, "ZodBoolean");
_ZodBoolean.create = /* @__PURE__ */ __name((params) => {
  return new _ZodBoolean(__spreadValues({
    typeName: "ZodBoolean" /* ZodBoolean */,
    coerce: (params == null ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
}, "create");
var ZodBoolean = _ZodBoolean;

// src/z/types/branded/index.ts
var BRAND = Symbol("zod_brand");
var _ZodBranded = class _ZodBranded extends ZodType {
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
__name(_ZodBranded, "ZodBranded");
var ZodBranded = _ZodBranded;

// src/z/types/catch/index.ts
var _ZodCatch = class _ZodCatch extends ZodType {
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const newCtx = __spreadProps(__spreadValues({}, ctx), {
      common: __spreadProps(__spreadValues({}, ctx.common), {
        issues: []
      })
    });
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: __spreadValues({}, newCtx)
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
__name(_ZodCatch, "ZodCatch");
_ZodCatch.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodCatch(__spreadValues({
    innerType: type,
    typeName: "ZodCatch" /* ZodCatch */,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch
  }, processCreateParams(params)));
}, "create");
var ZodCatch = _ZodCatch;

// src/z/types/custom/index.ts
var custom = /* @__PURE__ */ __name((check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) != null ? _a : fatal) != null ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, p2), { fatal: _fatal }));
      }
    });
  return ZodAny.create();
}, "custom");

// src/z/types/date/index.ts
var _ZodDate = class _ZodDate extends ZodType {
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = new Date(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input4.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input4.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input4.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input4.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  min(minDate, message2) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  max(maxDate, message2) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
__name(_ZodDate, "ZodDate");
_ZodDate.create = /* @__PURE__ */ __name((params) => {
  return new _ZodDate(__spreadValues({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: "ZodDate" /* ZodDate */
  }, processCreateParams(params)));
}, "create");
var ZodDate = _ZodDate;

// src/z/types/default/index.ts
var _ZodDefault = class _ZodDefault extends ZodType {
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
  dereference(defs) {
    return new _ZodDefault(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.dereference(defs)
    }));
  }
};
__name(_ZodDefault, "ZodDefault");
_ZodDefault.create = /* @__PURE__ */ __name((type, value, params) => {
  return new _ZodDefault(__spreadValues({
    innerType: type,
    typeName: "ZodDefault" /* ZodDefault */,
    defaultValue: typeof value === "function" ? value : () => value
  }, processCreateParams(params)));
}, "create");
var ZodDefault = _ZodDefault;

// src/z/utils.ts
var unique = /* @__PURE__ */ __name((arr) => {
  return Array.from(new Set(arr));
}, "unique");

// src/z/types/discriminatedUnion/index.ts
var getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
var _ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  dereference(defs) {
    const options = this.options.map((option) => option.dereference(defs));
    const optionsMap = _ZodDiscriminatedUnion._getOptionsMap(this.discriminator, options);
    return new _ZodDiscriminatedUnion(__spreadProps(__spreadValues({}, this._def), {
      options,
      optionsMap
    }));
  }
  getReferences() {
    return unique(this.options.flatMap((option) => option.getReferences()));
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = _ZodDiscriminatedUnion._getOptionsMap(discriminator, options);
    return new _ZodDiscriminatedUnion(__spreadValues({
      typeName: "ZodDiscriminatedUnion" /* ZodDiscriminatedUnion */,
      discriminator,
      options,
      optionsMap
    }, processCreateParams(params)));
  }
  static _getOptionsMap(discriminator, options) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(
          `A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`
        );
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return optionsMap;
  }
};
__name(_ZodDiscriminatedUnion, "ZodDiscriminatedUnion");
var ZodDiscriminatedUnion = _ZodDiscriminatedUnion;

// src/z/types/enum/index.ts
function createZodEnum(values, params) {
  return new ZodEnum(__spreadValues({
    values,
    typeName: "ZodEnum" /* ZodEnum */
  }, processCreateParams(params)));
}
__name(createZodEnum, "createZodEnum");
var _ZodEnum = class _ZodEnum extends ZodType {
  _parse(input4) {
    if (typeof input4.data !== "string") {
      const ctx = this._getOrReturnCtx(input4);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input4.data) === -1) {
      const ctx = this._getOrReturnCtx(input4);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, __spreadValues(__spreadValues({}, this._def), newDef));
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), __spreadValues(__spreadValues({}, this._def), newDef));
  }
};
__name(_ZodEnum, "ZodEnum");
_ZodEnum.create = createZodEnum;
var ZodEnum = _ZodEnum;

// src/z/types/function/index.ts
var _ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  dereference(defs) {
    const args = this._def.args.dereference(defs);
    const returns = this._def.returns.dereference(defs);
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      args,
      returns
    }));
  }
  getReferences() {
    return unique([...this._def.args.getReferences(), ...this._def.returns.getReferences()]);
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter(
          (x) => !!x
        ),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter(
          (x) => !!x
        ),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    }));
  }
  returns(returnType) {
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      returns: returnType
    }));
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction(__spreadValues({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: "ZodFunction" /* ZodFunction */
    }, processCreateParams(params)));
  }
};
__name(_ZodFunction, "ZodFunction");
var ZodFunction = _ZodFunction;

// src/z/types/intersection/index.ts
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = __spreadValues(__spreadValues({}, a), b);
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var _ZodIntersection = class _ZodIntersection extends ZodType {
  dereference(defs) {
    return new _ZodIntersection(__spreadProps(__spreadValues({}, this._def), {
      left: this._def.left.dereference(defs),
      right: this._def.right.dereference(defs)
    }));
  }
  getReferences() {
    return unique([...this._def.left.getReferences(), ...this._def.right.getReferences()]);
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(
        this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      );
    }
  }
};
__name(_ZodIntersection, "ZodIntersection");
_ZodIntersection.create = /* @__PURE__ */ __name((left, right, params) => {
  return new _ZodIntersection(__spreadValues({
    left,
    right,
    typeName: "ZodIntersection" /* ZodIntersection */
  }, processCreateParams(params)));
}, "create");
var ZodIntersection = _ZodIntersection;

// src/z/types/lazy/index.ts
var _ZodLazy = class _ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
__name(_ZodLazy, "ZodLazy");
_ZodLazy.create = /* @__PURE__ */ __name((getter, params) => {
  return new _ZodLazy(__spreadValues({
    getter,
    typeName: "ZodLazy" /* ZodLazy */
  }, processCreateParams(params)));
}, "create");
var ZodLazy = _ZodLazy;

// src/z/types/literal/index.ts
var _ZodLiteral = class _ZodLiteral extends ZodType {
  _parse(input4) {
    if (input4.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input4.data };
  }
  get value() {
    return this._def.value;
  }
};
__name(_ZodLiteral, "ZodLiteral");
_ZodLiteral.create = /* @__PURE__ */ __name((value, params) => {
  return new _ZodLiteral(__spreadValues({
    value,
    typeName: "ZodLiteral" /* ZodLiteral */
  }, processCreateParams(params)));
}, "create");
var ZodLiteral = _ZodLiteral;

// src/z/types/map/index.ts
var _ZodMap = class _ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  dereference(defs) {
    const keyType = this._def.keyType.dereference(defs);
    const valueType = this._def.valueType.dereference(defs);
    return new _ZodMap(__spreadProps(__spreadValues({}, this._def), {
      keyType,
      valueType
    }));
  }
  getReferences() {
    return unique([...this._def.keyType.getReferences(), ...this._def.valueType.getReferences()]);
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
__name(_ZodMap, "ZodMap");
_ZodMap.create = /* @__PURE__ */ __name((keyType, valueType, params) => {
  return new _ZodMap(__spreadValues({
    valueType,
    keyType,
    typeName: "ZodMap" /* ZodMap */
  }, processCreateParams(params)));
}, "create");
var ZodMap = _ZodMap;

// src/z/types/nan/index.ts
var _ZodNaN = class _ZodNaN extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input4.data };
  }
};
__name(_ZodNaN, "ZodNaN");
_ZodNaN.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNaN(__spreadValues({
    typeName: "ZodNaN" /* ZodNaN */
  }, processCreateParams(params)));
}, "create");
var ZodNaN = _ZodNaN;

// src/z/types/nativeEnum/index.ts
var _ZodNativeEnum = class _ZodNativeEnum extends ZodType {
  _parse(input4) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input4);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input4.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  get enum() {
    return this._def.values;
  }
};
__name(_ZodNativeEnum, "ZodNativeEnum");
_ZodNativeEnum.create = /* @__PURE__ */ __name((values, params) => {
  return new _ZodNativeEnum(__spreadValues({
    values,
    typeName: "ZodNativeEnum" /* ZodNativeEnum */
  }, processCreateParams(params)));
}, "create");
var ZodNativeEnum = _ZodNativeEnum;

// src/z/types/never/index.ts
var _ZodNever = class _ZodNever extends ZodType {
  _parse(input4) {
    const ctx = this._getOrReturnCtx(input4);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
__name(_ZodNever, "ZodNever");
_ZodNever.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNever(__spreadValues({
    typeName: "ZodNever" /* ZodNever */
  }, processCreateParams(params)));
}, "create");
var ZodNever = _ZodNever;

// src/z/types/null/index.ts
var _ZodNull = class _ZodNull extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
};
__name(_ZodNull, "ZodNull");
_ZodNull.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNull(__spreadValues({
    typeName: "ZodNull" /* ZodNull */
  }, processCreateParams(params)));
}, "create");
var ZodNull = _ZodNull;

// src/z/types/nullable/index.ts
var _ZodNullable = class _ZodNullable extends ZodType {
  dereference(defs) {
    return new _ZodNullable(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input4);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(_ZodNullable, "ZodNullable");
_ZodNullable.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodNullable(__spreadValues({
    innerType: type,
    typeName: "ZodNullable" /* ZodNullable */
  }, processCreateParams(params)));
}, "create");
var ZodNullable = _ZodNullable;

// src/z/types/number/index.ts
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
__name(floatSafeRemainder, "floatSafeRemainder");
var _ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = Number(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input4.data < check.value : input4.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input4.data > check.value : input4.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input4.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input4.data };
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  int(message2) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message2)
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  finite(message2) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message2)
    });
  }
  safe(message2) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
__name(_ZodNumber, "ZodNumber");
_ZodNumber.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNumber(__spreadValues({
    checks: [],
    typeName: "ZodNumber" /* ZodNumber */,
    coerce: (params == null ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
}, "create");
var ZodNumber = _ZodNumber;

// src/z/types/object/index.ts
function deepPartialify(schema) {
  if (schema instanceof ZodObject2) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject2(__spreadProps(__spreadValues({}, schema._def), {
      shape: () => newShape
    }));
  } else if (schema instanceof ZodArray) {
    return new ZodArray(__spreadProps(__spreadValues({}, schema._def), {
      type: deepPartialify(schema.element)
    }));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
var _ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    /**
     * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
     * If you want to pass through unknown properties, use `.passthrough()` instead.
     */
    this.nonstrict = this.passthrough;
    // extend<
    //   Augmentation extends ZodRawShape,
    //   NewOutput extends util.flatten<{
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   }>,
    //   NewInput extends util.flatten<{
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }>
    // >(
    //   augmentation: Augmentation
    // ): ZodObject<
    //   extendShape<T, Augmentation>,
    //   UnknownKeys,
    //   Catchall,
    //   NewOutput,
    //   NewInput
    // > {
    //   return new ZodObject({
    //     ...this._def,
    //     shape: () => ({
    //       ...this._def.shape(),
    //       ...augmentation,
    //     }),
    //   }) as any;
    // }
    /**
     * @deprecated Use `.extend` instead
     *  */
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  dereference(defs) {
    const currentShape = this._def.shape();
    const shape = {};
    for (const key in currentShape) {
      shape[key] = currentShape[key].dereference(defs);
    }
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => shape
    }));
  }
  getReferences() {
    const shape = this._def.shape();
    const refs = [];
    for (const key in shape) {
      refs.push(...shape[key].getReferences());
    }
    return unique(refs);
  }
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input4);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message2) {
    errorUtil.errToObj;
    return new _ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strict"
    }), message2 !== void 0 ? {
      errorMap: (issue, ctx) => {
        var _a, _b, _c, _d;
        const defaultError = (_c = (_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue, ctx).message) != null ? _c : ctx.defaultError;
        if (issue.code === "unrecognized_keys")
          return {
            message: (_d = errorUtil.errToObj(message2).message) != null ? _d : defaultError
          };
        return {
          message: defaultError
        };
      }
    } : {}));
  }
  strip() {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strip"
    }));
  }
  passthrough() {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "passthrough"
    }));
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => __spreadValues(__spreadValues({}, this._def.shape()), augmentation)
    }));
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => __spreadValues(__spreadValues({}, this._def.shape()), merging._def.shape()),
      typeName: "ZodObject" /* ZodObject */
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      catchall: index
    }));
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => shape
    }));
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => shape
    }));
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema == null ? void 0 : fieldSchema.optional();
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => newShape
    }));
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => newShape
    }));
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
__name(_ZodObject, "ZodObject");
_ZodObject.create = /* @__PURE__ */ __name((shape, params) => {
  return new _ZodObject(__spreadValues({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: "ZodObject" /* ZodObject */
  }, processCreateParams(params)));
}, "create");
_ZodObject.strictCreate = /* @__PURE__ */ __name((shape, params) => {
  return new _ZodObject(__spreadValues({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: "ZodObject" /* ZodObject */
  }, processCreateParams(params)));
}, "strictCreate");
_ZodObject.lazycreate = /* @__PURE__ */ __name((shape, params) => {
  return new _ZodObject(__spreadValues({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: "ZodObject" /* ZodObject */
  }, processCreateParams(params)));
}, "lazycreate");
var ZodObject2 = _ZodObject;

// src/z/types/optional/index.ts
var _ZodOptional = class _ZodOptional extends ZodType {
  dereference(defs) {
    return new _ZodOptional(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input4);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(_ZodOptional, "ZodOptional");
_ZodOptional.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodOptional(__spreadValues({
    innerType: type,
    typeName: "ZodOptional" /* ZodOptional */
  }, processCreateParams(params)));
}, "create");
var ZodOptional = _ZodOptional;

// src/z/types/pipeline/index.ts
var _ZodPipeline = class _ZodPipeline extends ZodType {
  dereference(defs) {
    return new _ZodPipeline(__spreadProps(__spreadValues({}, this._def), {
      in: this._def.in.dereference(defs),
      out: this._def.out.dereference(defs)
    }));
  }
  getReferences() {
    return unique([...this._def.in.getReferences(), ...this._def.out.getReferences()]);
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: "ZodPipeline" /* ZodPipeline */
    });
  }
};
__name(_ZodPipeline, "ZodPipeline");
var ZodPipeline = _ZodPipeline;

// src/z/types/promise/index.ts
var _ZodPromise = class _ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  dereference(defs) {
    return new _ZodPromise(__spreadProps(__spreadValues({}, this._def), {
      type: this._def.type.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.type.getReferences();
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(
      promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      })
    );
  }
};
__name(_ZodPromise, "ZodPromise");
_ZodPromise.create = /* @__PURE__ */ __name((schema, params) => {
  return new _ZodPromise(__spreadValues({
    type: schema,
    typeName: "ZodPromise" /* ZodPromise */
  }, processCreateParams(params)));
}, "create");
var ZodPromise = _ZodPromise;

// src/z/types/readonly/index.ts
var _ZodReadonly = class _ZodReadonly extends ZodType {
  dereference(defs) {
    return new _ZodReadonly(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  _parse(input4) {
    const result = this._def.innerType._parse(input4);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(_ZodReadonly, "ZodReadonly");
_ZodReadonly.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodReadonly(__spreadValues({
    innerType: type,
    typeName: "ZodReadonly" /* ZodReadonly */
  }, processCreateParams(params)));
}, "create");
var ZodReadonly = _ZodReadonly;

// src/z/types/record/index.ts
var _ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  dereference(defs) {
    const keyType = this._def.keyType.dereference(defs);
    const valueType = this._def.valueType.dereference(defs);
    return new _ZodRecord(__spreadProps(__spreadValues({}, this._def), {
      keyType,
      valueType
    }));
  }
  getReferences() {
    return unique([...this._def.keyType.getReferences(), ...this._def.valueType.getReferences()]);
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord(__spreadValues({
        keyType: first,
        valueType: second,
        typeName: "ZodRecord" /* ZodRecord */
      }, processCreateParams(third)));
    }
    return new _ZodRecord(__spreadValues({
      keyType: ZodString.create(),
      valueType: first,
      typeName: "ZodRecord" /* ZodRecord */
    }, processCreateParams(second)));
  }
};
__name(_ZodRecord, "ZodRecord");
var ZodRecord = _ZodRecord;

// src/z/types/ref/index.ts
var _ZodRef = class _ZodRef extends ZodType {
  dereference(defs) {
    const def = defs[this._def.uri];
    if (!def) {
      return this;
    }
    return def;
  }
  getReferences() {
    return [this._def.uri];
  }
  _parse(input4) {
    const ctx = this._getOrReturnCtx(input4);
    addIssueToContext(ctx, {
      code: ZodIssueCode.unresolved_reference
    });
    return INVALID;
  }
  isOptional() {
    return false;
  }
  isNullable() {
    return false;
  }
};
__name(_ZodRef, "ZodRef");
_ZodRef.create = /* @__PURE__ */ __name((uri) => {
  return new _ZodRef({
    typeName: "ZodRef" /* ZodRef */,
    uri
  });
}, "create");
var ZodRef = _ZodRef;

// src/z/types/set/index.ts
var _ZodSet = class _ZodSet extends ZodType {
  dereference(defs) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      valueType: this._def.valueType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.valueType.getReferences();
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map(
      (item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i))
    );
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message2) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      minSize: { value: minSize, message: errorUtil.toString(message2) }
    }));
  }
  max(maxSize, message2) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      maxSize: { value: maxSize, message: errorUtil.toString(message2) }
    }));
  }
  size(size, message2) {
    return this.min(size, message2).max(size, message2);
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
__name(_ZodSet, "ZodSet");
_ZodSet.create = /* @__PURE__ */ __name((valueType, params) => {
  return new _ZodSet(__spreadValues({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: "ZodSet" /* ZodSet */
  }, processCreateParams(params)));
}, "create");
var ZodSet = _ZodSet;

// src/z/types/string/index.ts
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var isEmojiRegex = /* @__PURE__ */ __name((value) => value === _emojiRegex, "isEmojiRegex");
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = /* @__PURE__ */ __name((args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(
        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
      );
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
}, "datetimeRegex");
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
var _ZodString = class _ZodString extends ZodType {
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = String(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input4.data.length < check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input4.data.length > check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input4.data.length > check.value;
        const tooSmall = input4.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input4, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input4.data);
        } catch (e) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input4.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input4.data = input4.data.trim();
      } else if (check.kind === "includes") {
        if (!input4.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input4.data = input4.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input4.data = input4.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input4.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input4.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input4.data, check.version)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input4.data };
  }
  _regex(regex, validation, message2) {
    return this.refinement((data) => regex.test(data), __spreadValues({
      validation,
      code: ZodIssueCode.invalid_string
    }, errorUtil.errToObj(message2)));
  }
  _addCheck(check) {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  email(message2) {
    return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message2)));
  }
  url(message2) {
    return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message2)));
  }
  emoji(message2) {
    return this._addCheck(__spreadValues({ kind: "emoji" }, errorUtil.errToObj(message2)));
  }
  uuid(message2) {
    return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message2)));
  }
  cuid(message2) {
    return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message2)));
  }
  cuid2(message2) {
    return this._addCheck(__spreadValues({ kind: "cuid2" }, errorUtil.errToObj(message2)));
  }
  ulid(message2) {
    return this._addCheck(__spreadValues({ kind: "ulid" }, errorUtil.errToObj(message2)));
  }
  ip(options) {
    return this._addCheck(__spreadValues({ kind: "ip" }, errorUtil.errToObj(options)));
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck(__spreadValues({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (_a = options == null ? void 0 : options.offset) != null ? _a : false
    }, errorUtil.errToObj(options == null ? void 0 : options.message)));
  }
  regex(regex, message2) {
    return this._addCheck(__spreadValues({
      kind: "regex",
      regex
    }, errorUtil.errToObj(message2)));
  }
  includes(value, options) {
    return this._addCheck(__spreadValues({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position
    }, errorUtil.errToObj(options == null ? void 0 : options.message)));
  }
  startsWith(value, message2) {
    return this._addCheck(__spreadValues({
      kind: "startsWith",
      value
    }, errorUtil.errToObj(message2)));
  }
  endsWith(value, message2) {
    return this._addCheck(__spreadValues({
      kind: "endsWith",
      value
    }, errorUtil.errToObj(message2)));
  }
  min(minLength, message2) {
    return this._addCheck(__spreadValues({
      kind: "min",
      value: minLength
    }, errorUtil.errToObj(message2)));
  }
  max(maxLength, message2) {
    return this._addCheck(__spreadValues({
      kind: "max",
      value: maxLength
    }, errorUtil.errToObj(message2)));
  }
  length(len, message2) {
    return this._addCheck(__spreadValues({
      kind: "length",
      value: len
    }, errorUtil.errToObj(message2)));
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message2) {
    return this.min(1, errorUtil.errToObj(message2));
  }
  trim() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "trim" }]
    }));
  }
  secret() {
    this._def[zuiKey] = __spreadProps(__spreadValues({}, this._def[zuiKey]), { secret: true });
    return this;
  }
  toLowerCase() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }));
  }
  toUpperCase() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    }));
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
__name(_ZodString, "ZodString");
_ZodString.create = /* @__PURE__ */ __name((params) => {
  var _a;
  return new _ZodString(__spreadValues({
    checks: [],
    typeName: "ZodString" /* ZodString */,
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false
  }, processCreateParams(params)));
}, "create");
var ZodString = _ZodString;

// src/z/types/symbol/index.ts
var _ZodSymbol = class _ZodSymbol extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
};
__name(_ZodSymbol, "ZodSymbol");
_ZodSymbol.create = /* @__PURE__ */ __name((params) => {
  return new _ZodSymbol(__spreadValues({
    typeName: "ZodSymbol" /* ZodSymbol */
  }, processCreateParams(params)));
}, "create");
var ZodSymbol = _ZodSymbol;

// src/z/types/templateLiteral/index.ts
var _ZodTemplateLiteral = class _ZodTemplateLiteral extends ZodType {
  interpolated(type) {
    return this._addPart(type);
  }
  literal(literal) {
    return this._addPart(literal);
  }
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = String(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.string) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (!new RegExp(this._def.regexString).test(input4.data)) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        message: `does not match template literal with pattern /${this._def.regexString}/`,
        path: ctx.path,
        validation: "regex"
      });
      return INVALID;
    }
    return { status: "valid", value: input4.data };
  }
  _addPart(part) {
    const parts = [...this._def.parts, part];
    return new _ZodTemplateLiteral(__spreadProps(__spreadValues({}, this._def), {
      parts,
      regexString: this._appendToRegexString(this._def.regexString, part)
    }));
  }
  _appendToRegexString(regexString, part) {
    return `^${this._unwrapRegExp(regexString)}${this._transformPartToRegexString(part)}$`;
  }
  _transformPartToRegexString(part) {
    if (!(part instanceof ZodType)) {
      return this._escapeRegExp(part);
    }
    if (part instanceof ZodLiteral) {
      return this._escapeRegExp(part._def.value);
    }
    if (part instanceof ZodString) {
      return this._transformZodStringPartToRegexString(part);
    }
    if (part instanceof ZodEnum || part instanceof ZodNativeEnum) {
      const values = part instanceof ZodEnum ? part._def.values : util.getValidEnumValues(part._def.values);
      return `(${values.map(this._escapeRegExp).join("|")})`;
    }
    if (part instanceof ZodUnion) {
      return `(${part._def.options.map((option) => this._transformPartToRegexString(option)).join("|")})`;
    }
    if (part instanceof ZodNumber) {
      return this._transformZodNumberPartToRegexString(part);
    }
    if (part instanceof ZodOptional) {
      return `(${this._transformPartToRegexString(part.unwrap())})?`;
    }
    if (part instanceof _ZodTemplateLiteral) {
      return this._unwrapRegExp(part._def.regexString);
    }
    if (part instanceof ZodBigInt) {
      return "\\-?\\d+";
    }
    if (part instanceof ZodBoolean) {
      return "(true|false)";
    }
    if (part instanceof ZodNullable) {
      do {
        part = part.unwrap();
      } while (part instanceof ZodNullable);
      return `(${this._transformPartToRegexString(part)}|null)${part instanceof ZodOptional ? "?" : ""}`;
    }
    if (part instanceof ZodBranded) {
      return this._transformPartToRegexString(part.unwrap());
    }
    if (part instanceof ZodAny) {
      return ".*";
    }
    if (part instanceof ZodNull) {
      return "null";
    }
    if (part instanceof ZodUndefined) {
      return "undefined";
    }
    throw new ZodTemplateLiteralUnsupportedTypeError();
  }
  // FIXME: we don't support transformations, so `.trim()` is not supported.
  _transformZodStringPartToRegexString(part) {
    let maxLength = Infinity, minLength = 0, endsWith = "", startsWith = "";
    for (const ch of part._def.checks) {
      const regex = this._resolveRegexForStringCheck(ch);
      if (regex) {
        return this._unwrapRegExp(regex);
      }
      if (ch.kind === "endsWith") {
        endsWith = ch.value;
      } else if (ch.kind === "length") {
        minLength = maxLength = ch.value;
      } else if (ch.kind === "max") {
        maxLength = Math.max(0, Math.min(maxLength, ch.value));
      } else if (ch.kind === "min") {
        minLength = Math.max(minLength, ch.value);
      } else if (ch.kind === "startsWith") {
        startsWith = ch.value;
      } else {
        throw new ZodTemplateLiteralUnsupportedCheckError("ZodString" /* ZodString */, ch.kind);
      }
    }
    const constrainedMinLength = Math.max(0, minLength - startsWith.length - endsWith.length);
    const constrainedMaxLength = Number.isFinite(maxLength) ? Math.max(0, maxLength - startsWith.length - endsWith.length) : Infinity;
    if (constrainedMaxLength === 0 || constrainedMinLength > constrainedMaxLength) {
      return `${startsWith}${endsWith}`;
    }
    return `${startsWith}.${this._resolveRegexWildcardLength(constrainedMinLength, constrainedMaxLength)}${endsWith}`;
  }
  _resolveRegexForStringCheck(check) {
    var _a;
    return (_a = {
      [check.kind]: null,
      cuid: cuidRegex,
      cuid2: cuid2Regex,
      datetime: check.kind === "datetime" ? datetimeRegex(check) : null,
      email: emailRegex,
      ip: check.kind === "ip" ? {
        any: new RegExp(
          `^(${this._unwrapRegExp(ipv4Regex.source)})|(${this._unwrapRegExp(ipv6Regex.source)})$`
        ),
        v4: ipv4Regex,
        v6: ipv6Regex
      }[check.version || "any"] : null,
      regex: check.kind === "regex" ? check.regex : null,
      ulid: ulidRegex,
      uuid: uuidRegex
    }[check.kind]) != null ? _a : null;
  }
  _resolveRegexWildcardLength(minLength, maxLength) {
    if (minLength === maxLength) {
      return minLength === 1 ? "" : `{${minLength}}`;
    }
    if (maxLength !== Infinity) {
      return `{${minLength},${maxLength}}`;
    }
    if (minLength === 0) {
      return "*";
    }
    if (minLength === 1) {
      return "+";
    }
    return `{${minLength},}`;
  }
  // FIXME: we do not support exponent notation (e.g. 2e5) since it conflicts with `.int()`.
  _transformZodNumberPartToRegexString(part) {
    let canBeNegative = true, canBePositive = true, min = -Infinity, max = Infinity, canBeZero = true, isFinite2 = false, isInt = false, acc = "";
    for (const ch of part._def.checks) {
      if (ch.kind === "finite") {
        isFinite2 = true;
      } else if (ch.kind === "int") {
        isInt = true;
      } else if (ch.kind === "max") {
        max = Math.min(max, ch.value);
        if (ch.value <= 0) {
          canBePositive = false;
          if (ch.value === 0 && !ch.inclusive) {
            canBeZero = false;
          }
        }
      } else if (ch.kind === "min") {
        min = Math.max(min, ch.value);
        if (ch.value >= 0) {
          canBeNegative = false;
          if (ch.value === 0 && !ch.inclusive) {
            canBeZero = false;
          }
        }
      } else {
        throw new ZodTemplateLiteralUnsupportedCheckError("ZodNumber" /* ZodNumber */, ch.kind);
      }
    }
    if (Number.isFinite(min) && Number.isFinite(max)) {
      isFinite2 = true;
    }
    if (canBeNegative) {
      acc = `${acc}\\-`;
      if (canBePositive) {
        acc = `${acc}?`;
      }
    } else if (!canBePositive) {
      return "0+";
    }
    if (!isFinite2) {
      acc = `${acc}(Infinity|(`;
    }
    if (!canBeZero) {
      if (!isInt) {
        acc = `${acc}((\\d*[1-9]\\d*(\\.\\d+)?)|(\\d+\\.\\d*[1-9]\\d*))`;
      } else {
        acc = `${acc}\\d*[1-9]\\d*`;
      }
    } else if (isInt) {
      acc = `${acc}\\d+`;
    } else {
      acc = `${acc}\\d+(\\.\\d+)?`;
    }
    if (!isFinite2) {
      acc = `${acc}))`;
    }
    return acc;
  }
  _unwrapRegExp(regex) {
    const flags = typeof regex === "string" ? "" : regex.flags;
    const source = typeof regex === "string" ? regex : regex.source;
    if (flags.includes("i")) {
      return this._unwrapRegExp(this._makeRegexStringCaseInsensitive(source));
    }
    return source.replace(/(^\^)|(\$$)/g, "");
  }
  _makeRegexStringCaseInsensitive(regexString) {
    const isAlphabetic = /* @__PURE__ */ __name((char) => char.match(/[a-z]/i) != null, "isAlphabetic");
    let caseInsensitive = "";
    let inCharacterSet = false;
    for (let i = 0; i < regexString.length; i++) {
      const char = regexString.charAt(i);
      const nextChar = regexString.charAt(i + 1);
      if (char === "\\") {
        caseInsensitive += `${char}${nextChar}`;
        i++;
        continue;
      }
      if (char === "[") {
        inCharacterSet = true;
      } else if (inCharacterSet && char === "]") {
        inCharacterSet = false;
      }
      if (!isAlphabetic(char)) {
        caseInsensitive += char;
        continue;
      }
      if (!inCharacterSet) {
        caseInsensitive += `[${char.toLowerCase()}${char.toUpperCase()}]`;
        continue;
      }
      const charAfterNext = regexString.charAt(i + 2);
      if (nextChar !== "-" || !isAlphabetic(charAfterNext)) {
        caseInsensitive += `${char.toLowerCase()}${char.toUpperCase()}`;
        continue;
      }
      caseInsensitive += `${char.toLowerCase()}-${charAfterNext.toLowerCase()}${char.toUpperCase()}-${charAfterNext.toUpperCase()}`;
      i += 2;
    }
    return caseInsensitive;
  }
  _escapeRegExp(str) {
    if (typeof str !== "string") {
      str = `${str}`;
    }
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};
__name(_ZodTemplateLiteral, "ZodTemplateLiteral");
_ZodTemplateLiteral.create = /* @__PURE__ */ __name((params) => {
  var _a;
  return new _ZodTemplateLiteral(__spreadProps(__spreadValues({}, processCreateParams(params)), {
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false,
    parts: [],
    regexString: "^$",
    typeName: "ZodTemplateLiteral" /* ZodTemplateLiteral */
  }));
}, "create");
var ZodTemplateLiteral = _ZodTemplateLiteral;

// src/z/types/transformer/index.ts
var _ZodEffects = class _ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === "ZodEffects" /* ZodEffects */ ? this._def.schema.sourceType() : this._def.schema;
  }
  dereference(defs) {
    return new _ZodEffects(__spreadProps(__spreadValues({}, this._def), {
      schema: this._def.schema.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.schema.getReferences();
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(
            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
          );
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
__name(_ZodEffects, "ZodEffects");
_ZodEffects.create = /* @__PURE__ */ __name((schema, effect, params) => {
  return new _ZodEffects(__spreadValues({
    schema,
    typeName: "ZodEffects" /* ZodEffects */,
    effect
  }, processCreateParams(params)));
}, "create");
_ZodEffects.createWithPreprocess = /* @__PURE__ */ __name((preprocess, schema, params) => {
  return new _ZodEffects(__spreadValues({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: "ZodEffects" /* ZodEffects */
  }, processCreateParams(params)));
}, "createWithPreprocess");
var ZodEffects = _ZodEffects;

// src/z/types/tuple/index.ts
var _ZodTuple = class _ZodTuple extends ZodType {
  dereference(defs) {
    const items = this._def.items.map((item) => item.dereference(defs));
    const rest = this._def.rest ? this._def.rest.dereference(defs) : null;
    return new _ZodTuple(__spreadProps(__spreadValues({}, this._def), {
      items,
      rest
    }));
  }
  getReferences() {
    return unique([
      ...this._def.items.flatMap((item) => item.getReferences()),
      ...this._def.rest ? this._def.rest.getReferences() : []
    ]);
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple(__spreadProps(__spreadValues({}, this._def), {
      rest
    }));
  }
};
__name(_ZodTuple, "ZodTuple");
_ZodTuple.create = /* @__PURE__ */ __name((schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new _ZodTuple(__spreadValues({
    items: schemas,
    typeName: "ZodTuple" /* ZodTuple */,
    rest: null
  }, processCreateParams(params)));
}, "create");
var ZodTuple = _ZodTuple;

// src/z/types/undefined/index.ts
var _ZodUndefined = class _ZodUndefined extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
};
__name(_ZodUndefined, "ZodUndefined");
_ZodUndefined.create = /* @__PURE__ */ __name((params) => {
  return new _ZodUndefined(__spreadValues({
    typeName: "ZodUndefined" /* ZodUndefined */
  }, processCreateParams(params)));
}, "create");
var ZodUndefined = _ZodUndefined;

// src/z/types/union/index.ts
var _ZodUnion = class _ZodUnion extends ZodType {
  dereference(defs) {
    const options = this._def.options.map((option) => option.dereference(defs));
    return new _ZodUnion(__spreadProps(__spreadValues({}, this._def), {
      options
    }));
  }
  getReferences() {
    return unique(
      this._def.options.reduce((acc, option) => {
        return [...acc, ...option.getReferences()];
      }, [])
    );
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(
        options.map(async (option) => {
          const childCtx = __spreadProps(__spreadValues({}, ctx), {
            common: __spreadProps(__spreadValues({}, ctx.common), {
              issues: []
            }),
            parent: null
          });
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })
      ).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = __spreadProps(__spreadValues({}, ctx), {
          common: __spreadProps(__spreadValues({}, ctx.common), {
            issues: []
          }),
          parent: null
        });
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
__name(_ZodUnion, "ZodUnion");
_ZodUnion.create = /* @__PURE__ */ __name((types, params) => {
  return new _ZodUnion(__spreadValues({
    options: types,
    typeName: "ZodUnion" /* ZodUnion */
  }, processCreateParams(params)));
}, "create");
var ZodUnion = _ZodUnion;

// src/z/types/unknown/index.ts
var _ZodUnknown = class _ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    // required
    this._unknown = true;
  }
  _parse(input4) {
    return OK(input4.data);
  }
};
__name(_ZodUnknown, "ZodUnknown");
_ZodUnknown.create = /* @__PURE__ */ __name((params) => {
  return new _ZodUnknown(__spreadValues({
    typeName: "ZodUnknown" /* ZodUnknown */
  }, processCreateParams(params)));
}, "create");
var ZodUnknown = _ZodUnknown;

// src/z/types/void/index.ts
var _ZodVoid = class _ZodVoid extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
};
__name(_ZodVoid, "ZodVoid");
_ZodVoid.create = /* @__PURE__ */ __name((params) => {
  return new _ZodVoid(__spreadValues({
    typeName: "ZodVoid" /* ZodVoid */
  }, processCreateParams(params)));
}, "create");
var ZodVoid = _ZodVoid;

// src/transforms/object-to-zui/index.ts
var dateTimeRegex = /^\d{4}-\d{2}-\d{2}(T|\s)?((\d{2}:\d{2}:\d{2}(\.\d{1,3})?)|(\d{2}:\d{2}))?(\s?([+-]\d{2}:\d{2}|Z))?$/;
var objectToZui = /* @__PURE__ */ __name((obj, opts, isRoot = true) => {
  if (typeof obj !== "object") {
    throw new Error("Input must be an object");
  }
  const applyOptions = /* @__PURE__ */ __name((zodType) => {
    let newType = zodType;
    if (opts == null ? void 0 : opts.nullable) {
      newType = newType.nullable();
    }
    if (opts == null ? void 0 : opts.optional) {
      newType = newType.optional();
    }
    if ((opts == null ? void 0 : opts.passtrough) && typeof newType.passthrough === "function") {
      newType = newType.passthrough();
    }
    return newType;
  }, "applyOptions");
  const schema = Object.entries(obj).reduce((acc, [key, value]) => {
    if (value === null) {
      acc[key] = applyOptions(z_exports.null());
    } else {
      switch (typeof value) {
        case "string":
          acc[key] = dateTimeRegex.test(value) ? applyOptions(z_exports.string().datetime()) : applyOptions(z_exports.string());
          break;
        case "number":
          acc[key] = applyOptions(z_exports.number());
          break;
        case "boolean":
          acc[key] = applyOptions(z_exports.boolean());
          break;
        case "object":
          if (Array.isArray(value)) {
            if (value.length === 0) {
              acc[key] = applyOptions(z_exports.array(z_exports.unknown()));
            } else if (typeof value[0] === "object") {
              acc[key] = applyOptions(z_exports.array(objectToZui(value[0], opts, false)));
            } else if (["string", "number", "boolean"].includes(typeof value[0])) {
              acc[key] = applyOptions(z_exports.array(z_exports[typeof value[0]]()));
            }
          } else {
            acc[key] = applyOptions(objectToZui(value, opts, false));
          }
          break;
        default:
          throw new Error(`Unsupported type for key ${key}`);
      }
    }
    return acc;
  }, {});
  const hasProperties = Object.keys(schema).length > 0;
  if ((opts == null ? void 0 : opts.passtrough) || !isRoot && !hasProperties) {
    return z_exports.object(schema).passthrough();
  }
  return z_exports.object(schema);
}, "objectToZui");

// src/transforms/zui-to-json-schema/parsers/any.ts
function parseAnyDef() {
  return {};
}
__name(parseAnyDef, "parseAnyDef");

// src/transforms/zui-to-json-schema/errorMessages.ts
function addErrorMessage(res, key, errorMessage, refs) {
  if (!(refs == null ? void 0 : refs.errorMessages))
    return;
  if (errorMessage) {
    res.errorMessage = __spreadProps(__spreadValues({}, res.errorMessage), {
      [key]: errorMessage
    });
  }
}
__name(addErrorMessage, "addErrorMessage");
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}
__name(setResponseValueAndErrors, "setResponseValueAndErrors");

// src/transforms/zui-to-json-schema/parsers/array.ts
function parseArrayDef(def, refs) {
  var _a, _b;
  const res = {
    type: "array"
  };
  if (((_b = (_a = def.type) == null ? void 0 : _a._def) == null ? void 0 : _b.typeName) !== "ZodAny" /* ZodAny */) {
    res.items = parseDef(def.type._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "items"]
    }));
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
__name(parseArrayDef, "parseArrayDef");

// src/transforms/zui-to-json-schema/parsers/bigint.ts
function parseBigintDef(def, refs) {
  const res = __spreadValues({
    type: "integer",
    format: "int64"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
__name(parseBigintDef, "parseBigintDef");

// src/transforms/zui-to-json-schema/parsers/boolean.ts
function parseBooleanDef(def) {
  return __spreadValues({
    type: "boolean"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
}
__name(parseBooleanDef, "parseBooleanDef");

// src/transforms/zui-to-json-schema/parsers/branded.ts
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
__name(parseBrandedDef, "parseBrandedDef");

// src/transforms/zui-to-json-schema/parsers/catch.ts
var parseCatchDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseCatchDef");

// src/transforms/zui-to-json-schema/parsers/date.ts
function parseDateDef(def, refs) {
  if (refs.dateStrategy == "integer") {
    return integerDateParser(def, refs);
  } else {
    return __spreadValues({
      type: "string",
      format: "date-time"
    }, def.coerce ? {
      [zuiKey]: {
        coerce: def.coerce || void 0
      }
    } : {});
  }
}
__name(parseDateDef, "parseDateDef");
var integerDateParser = /* @__PURE__ */ __name((def, refs) => {
  const res = __spreadValues({
    type: "integer",
    format: "unix-time"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          setResponseValueAndErrors(
            res,
            "minimum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          setResponseValueAndErrors(
            res,
            "maximum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
        }
        break;
    }
  }
  return res;
}, "integerDateParser");

// src/transforms/zui-to-json-schema/parsers/default.ts
function parseDefaultDef(_def, refs) {
  return __spreadProps(__spreadValues({}, parseDef(_def.innerType._def, refs)), {
    default: _def.defaultValue()
  });
}
__name(parseDefaultDef, "parseDefaultDef");

// src/transforms/zui-to-json-schema/parsers/effects.ts
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
}
__name(parseEffectsDef, "parseEffectsDef");

// src/transforms/zui-to-json-schema/parsers/enum.ts
function parseEnumDef(def) {
  return {
    type: "string",
    enum: def.values
  };
}
__name(parseEnumDef, "parseEnumDef");

// src/transforms/zui-to-json-schema/parsers/intersection.ts
var isJsonSchema7AllOfType = /* @__PURE__ */ __name((type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
}, "isJsonSchema7AllOfType");
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "0"]
    })),
    parseDef(def.right._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "1"]
    }))
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const _a = schema, { additionalProperties } = _a, rest = __objRest(_a, ["additionalProperties"]);
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? __spreadValues({
    allOf: mergedAllOf
  }, unevaluatedProperties) : void 0;
}
__name(parseIntersectionDef, "parseIntersectionDef");

// src/transforms/zui-to-json-schema/parsers/literal.ts
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
__name(parseLiteralDef, "parseLiteralDef");

// src/transforms/zui-to-json-schema/parsers/string.ts
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: "^[cC][^\\s-]{8,}$",
  cuid2: "^[a-z][a-z0-9]*$",
  ulid: "^[0-9A-HJKMNP-TV-Z]{26}$",
  /**
   * `a-z` was added to replicate /i flag
   */
  email: "^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_+-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$",
  emoji: "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  /**
   * Unused
   */
  uuid: "^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$",
  /**
   * Unused
   */
  ipv4: "^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$",
  /**
   * Unused
   */
  ipv6: "^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$"
};
function parseStringDef(def, refs) {
  const res = __spreadValues({
    type: "string"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
  }
  __name(processPattern, "processPattern");
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(
            res,
            "minLength",
            typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value,
            check.message,
            refs
          );
          break;
        case "max":
          setResponseValueAndErrors(
            res,
            "maxLength",
            typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value,
            check.message,
            refs
          );
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex.source, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, "^" + processPattern(check.value), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, processPattern(check.value) + "$", check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(
            res,
            "minLength",
            typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value,
            check.message,
            refs
          );
          setResponseValueAndErrors(
            res,
            "maxLength",
            typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value,
            check.message,
            refs
          );
          break;
        case "includes": {
          addPattern(res, processPattern(check.value), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji, check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          ;
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
__name(parseStringDef, "parseStringDef");
var escapeNonAlphaNumeric = /* @__PURE__ */ __name((value) => Array.from(value).map((c) => /[a-zA-Z0-9]/.test(c) ? c : `\\${c}`).join(""), "escapeNonAlphaNumeric");
var addFormat = /* @__PURE__ */ __name((schema, value, message2, refs) => {
  var _a;
  if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push(__spreadValues({
        format: schema.format
      }, schema.errorMessage && refs.errorMessages && {
        errorMessage: { format: schema.errorMessage.format }
      }));
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push(__spreadValues({
      format: value
    }, message2 && refs.errorMessages && { errorMessage: { format: message2 } }));
  } else {
    setResponseValueAndErrors(schema, "format", value, message2, refs);
  }
}, "addFormat");
var addPattern = /* @__PURE__ */ __name((schema, value, message2, refs) => {
  var _a;
  if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push(__spreadValues({
        pattern: schema.pattern
      }, schema.errorMessage && refs.errorMessages && {
        errorMessage: { pattern: schema.errorMessage.pattern }
      }));
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push(__spreadValues({
      pattern: value
    }, message2 && refs.errorMessages && { errorMessage: { pattern: message2 } }));
  } else {
    setResponseValueAndErrors(schema, "pattern", value, message2, refs);
  }
}, "addPattern");

// src/transforms/zui-to-json-schema/parsers/record.ts
function parseRecordDef(def, refs) {
  var _a, _b, _c, _d, _e;
  if (refs.target === "openApi3" && ((_a = def.keyType) == null ? void 0 : _a._def.typeName) === "ZodEnum" /* ZodEnum */) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce(
        (acc, key) => {
          var _a2;
          return __spreadProps(__spreadValues({}, acc), {
            [key]: (_a2 = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
              currentPath: [...refs.currentPath, "properties", key]
            }))) != null ? _a2 : {}
          });
        },
        {}
      ),
      additionalProperties: false
    };
  }
  const schema = {
    type: "object",
    additionalProperties: (_b = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }))) != null ? _b : {}
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (((_c = def.keyType) == null ? void 0 : _c._def.typeName) === "ZodString" /* ZodString */ && ((_d = def.keyType._def.checks) == null ? void 0 : _d.length)) {
    const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce(
      (acc, [key, value]) => key === "type" ? acc : __spreadProps(__spreadValues({}, acc), { [key]: value }),
      {}
    );
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: keyType
    });
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === "ZodEnum" /* ZodEnum */) {
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: {
        enum: def.keyType._def.values
      }
    });
  }
  return schema;
}
__name(parseRecordDef, "parseRecordDef");

// src/transforms/zui-to-json-schema/parsers/map.ts
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "0"]
  })) || {};
  const values = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "1"]
  })) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
__name(parseMapDef, "parseMapDef");

// src/transforms/zui-to-json-schema/parsers/nativeEnum.ts
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues.filter(
      (value) => typeof value === "string" || typeof value === "number"
    )
  };
}
__name(parseNativeEnumDef, "parseNativeEnumDef");

// src/transforms/zui-to-json-schema/parsers/never.ts
function parseNeverDef() {
  return {
    not: {}
  };
}
__name(parseNeverDef, "parseNeverDef");

// src/transforms/zui-to-json-schema/parsers/null.ts
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
__name(parseNullDef, "parseNullDef");

// src/transforms/zui-to-json-schema/parsers/union.ts
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asUnionOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [...acc, ...x._def.values.filter((x2) => !acc.includes(x2))],
        []
      )
    };
  }
  return asUnionOf(def, refs);
}
__name(parseUnionDef, "parseUnionDef");
var asUnionOf = /* @__PURE__ */ __name((def, refs) => {
  const unionOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, refs.unionStrategy, `${i}`]
    }))
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  const discriminator = refs.discriminator && def.typeName === "ZodDiscriminatedUnion" && typeof def.discriminator === "string" ? { discriminator: { propertyName: def.discriminator } } : {};
  if (!unionOf.length) {
    return void 0;
  }
  return refs.unionStrategy === "anyOf" ? __spreadValues({ anyOf: unionOf }, discriminator) : __spreadValues({ oneOf: unionOf }, discriminator);
}, "asUnionOf");

// src/transforms/zui-to-json-schema/parsers/nullable.ts
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [primitiveMappings[def.innerType._def.typeName], "null"]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath]
    }));
    return base2 && __spreadProps(__spreadValues({}, base2), { nullable: true });
  }
  const base = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "0"]
  }));
  return base && { anyOf: [base, { type: "null" }] };
}
__name(parseNullableDef, "parseNullableDef");

// src/transforms/zui-to-json-schema/parsers/number.ts
function parseNumberDef(def, refs) {
  const res = __spreadValues({
    type: "number"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
__name(parseNumberDef, "parseNumberDef");

// src/transforms/zui-to-json-schema/parsers/object.ts
function parseObjectDef(def, refs) {
  var _a;
  const result = __spreadProps(__spreadValues({
    type: "object"
  }, Object.entries(def.shape()).reduce(
    (acc, [propName, propDef]) => {
      if (propDef === void 0 || propDef._def === void 0)
        return acc;
      const parsedDef = parseDef(propDef._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      }));
      if (parsedDef === void 0)
        return acc;
      return {
        properties: __spreadProps(__spreadValues({}, acc.properties), { [propName]: parsedDef }),
        required: propDef.isOptional() ? acc.required : [...acc.required, propName]
      };
    },
    { properties: {}, required: [] }
  )), {
    additionalProperties: def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : (_a = parseDef(def.catchall._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }))) != null ? _a : true
  });
  if (!result.required.length)
    delete result.required;
  return result;
}
__name(parseObjectDef, "parseObjectDef");

// src/transforms/zui-to-json-schema/parsers/optional.ts
var parseOptionalDef = /* @__PURE__ */ __name((def, refs) => {
  var _a;
  if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "1"]
  }));
  return innerSchema ? {
    anyOf: [
      {
        not: {}
      },
      innerSchema
    ]
  } : {};
}, "parseOptionalDef");

// src/transforms/zui-to-json-schema/parsers/pipeline.ts
var parsePipelineDef = /* @__PURE__ */ __name((def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", "0"]
  }));
  const b = parseDef(def.out._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  }));
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
}, "parsePipelineDef");

// src/transforms/zui-to-json-schema/parsers/promise.ts
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
__name(parsePromiseDef, "parsePromiseDef");

// src/transforms/zui-to-json-schema/parsers/set.ts
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items"]
  }));
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
__name(parseSetDef, "parseSetDef");

// src/transforms/zui-to-json-schema/parsers/tuple.ts
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i}`]
        }))
      ).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "additionalItems"]
      }))
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i}`]
        }))
      ).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
__name(parseTupleDef, "parseTupleDef");

// src/transforms/zui-to-json-schema/parsers/undefined.ts
function parseUndefinedDef() {
  return {
    not: {}
  };
}
__name(parseUndefinedDef, "parseUndefinedDef");

// src/transforms/zui-to-json-schema/parsers/unknown.ts
function parseUnknownDef() {
  return {};
}
__name(parseUnknownDef, "parseUnknownDef");

// src/transforms/zui-to-json-schema/parsers/readonly.ts
var parseReadonlyDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseReadonlyDef");

// src/transforms/zui-to-json-schema/parsers/ref.ts
function parseRefDef(def) {
  return {
    $ref: def.uri
  };
}
__name(parseRefDef, "parseRefDef");

// src/transforms/zui-to-json-schema/parseDef.ts
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchema = selectParser(def, def.typeName, refs);
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
__name(parseDef, "parseDef");
var get$ref = /* @__PURE__ */ __name((item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return {};
      }
      return refs.$refStrategy === "seen" ? {} : void 0;
    }
  }
}, "get$ref");
var getRelativePath = /* @__PURE__ */ __name((pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
}, "getRelativePath");
var selectParser = /* @__PURE__ */ __name((def, typeName, refs) => {
  switch (typeName) {
    case "ZodString" /* ZodString */:
      return parseStringDef(def, refs);
    case "ZodNumber" /* ZodNumber */:
      return parseNumberDef(def, refs);
    case "ZodObject" /* ZodObject */:
      return parseObjectDef(def, refs);
    case "ZodBigInt" /* ZodBigInt */:
      return parseBigintDef(def, refs);
    case "ZodBoolean" /* ZodBoolean */:
      return parseBooleanDef(def);
    case "ZodDate" /* ZodDate */:
      return parseDateDef(def, refs);
    case "ZodUndefined" /* ZodUndefined */:
      return parseUndefinedDef();
    case "ZodNull" /* ZodNull */:
      return parseNullDef(refs);
    case "ZodArray" /* ZodArray */:
      return parseArrayDef(def, refs);
    case "ZodUnion" /* ZodUnion */:
    case "ZodDiscriminatedUnion" /* ZodDiscriminatedUnion */:
      return parseUnionDef(def, refs);
    case "ZodIntersection" /* ZodIntersection */:
      return parseIntersectionDef(def, refs);
    case "ZodTuple" /* ZodTuple */:
      return parseTupleDef(def, refs);
    case "ZodRecord" /* ZodRecord */:
      return parseRecordDef(def, refs);
    case "ZodRef" /* ZodRef */:
      return parseRefDef(def);
    case "ZodLiteral" /* ZodLiteral */:
      return parseLiteralDef(def, refs);
    case "ZodEnum" /* ZodEnum */:
      return parseEnumDef(def);
    case "ZodNativeEnum" /* ZodNativeEnum */:
      return parseNativeEnumDef(def);
    case "ZodNullable" /* ZodNullable */:
      return parseNullableDef(def, refs);
    case "ZodOptional" /* ZodOptional */:
      return parseOptionalDef(def, refs);
    case "ZodMap" /* ZodMap */:
      return parseMapDef(def, refs);
    case "ZodSet" /* ZodSet */:
      return parseSetDef(def, refs);
    case "ZodLazy" /* ZodLazy */:
      return parseDef(def.getter()._def, refs);
    case "ZodPromise" /* ZodPromise */:
      return parsePromiseDef(def, refs);
    case "ZodNaN" /* ZodNaN */:
    case "ZodNever" /* ZodNever */:
      return parseNeverDef();
    case "ZodEffects" /* ZodEffects */:
      return parseEffectsDef(def, refs);
    case "ZodAny" /* ZodAny */:
      return parseAnyDef();
    case "ZodUnknown" /* ZodUnknown */:
      return parseUnknownDef();
    case "ZodDefault" /* ZodDefault */:
      return parseDefaultDef(def, refs);
    case "ZodBranded" /* ZodBranded */:
      return parseBrandedDef(def, refs);
    case "ZodReadonly" /* ZodReadonly */:
      return parseReadonlyDef(def, refs);
    case "ZodCatch" /* ZodCatch */:
      return parseCatchDef(def, refs);
    case "ZodPipeline" /* ZodPipeline */:
      return parsePipelineDef(def, refs);
    case "ZodTemplateLiteral" /* ZodTemplateLiteral */:
      throw new Error("Template literals are not supported yet");
    case "ZodFunction" /* ZodFunction */:
    case "ZodVoid" /* ZodVoid */:
    case "ZodSymbol" /* ZodSymbol */:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
}, "selectParser");
var addMeta = /* @__PURE__ */ __name((def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  Object.assign(jsonSchema, { [zuiKey]: __spreadValues(__spreadValues({}, def[zuiKey]), jsonSchema[zuiKey]) });
  return jsonSchema;
}, "addMeta");

// src/transforms/zui-to-json-schema/Options.ts
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "string",
  mapStrategy: "entries",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  emailStrategy: "format:email",
  discriminator: false,
  unionStrategy: "anyOf"
};
var getDefaultOptions = /* @__PURE__ */ __name((options) => typeof options === "string" ? __spreadProps(__spreadValues({}, defaultOptions), {
  name: options
}) : __spreadValues(__spreadValues({}, defaultOptions), options), "getDefaultOptions");

// src/transforms/zui-to-json-schema/Refs.ts
var getRefs = /* @__PURE__ */ __name((options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return __spreadProps(__spreadValues({}, _options), {
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  });
}, "getRefs");

// src/transforms/zui-to-json-schema/zodToJsonSchema.ts
var zodToJsonSchema = /* @__PURE__ */ __name((schema, options) => {
  var _a;
  const refs = getRefs(options);
  const definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name2, schema2]) => {
      var _a2;
      return __spreadProps(__spreadValues({}, acc), {
        [name2]: (_a2 = parseDef(
          schema2._def,
          __spreadProps(__spreadValues({}, refs), {
            currentPath: [...refs.basePath, refs.definitionPath, name2]
          }),
          true
        )) != null ? _a2 : {}
      });
    },
    {}
  ) : void 0;
  const name = typeof options === "string" ? options : options == null ? void 0 : options.name;
  const main = (_a = parseDef(
    schema._def,
    name === void 0 ? refs : __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.basePath, refs.definitionPath, name]
    }),
    false
  )) != null ? _a : {};
  const combined = name === void 0 ? definitions ? __spreadProps(__spreadValues({}, main), {
    [refs.definitionPath]: definitions
  }) : main : {
    $ref: [...refs.$refStrategy === "relative" ? [] : refs.basePath, refs.definitionPath, name].join("/"),
    [refs.definitionPath]: __spreadProps(__spreadValues({}, definitions), {
      [name]: main
    })
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  return combined;
}, "zodToJsonSchema");

// src/transforms/zui-to-json-schema/zui-extension.ts
var zuiToJsonSchema = /* @__PURE__ */ __name((zuiType, opts = { target: "openApi3" }) => {
  const jsonSchema = zodToJsonSchema(zuiType, opts);
  if (opts.$schemaUrl === false) {
    delete jsonSchema.$schema;
  } else if (typeof opts.$schemaUrl === "string") {
    jsonSchema.$schema = opts.$schemaUrl;
  }
  return jsonSchema;
}, "zuiToJsonSchema");

// src/z/extensions.ts
var AI_MODELS = [
  "gpt-3.5-turbo",
  "gpt-3.5-turbo-16k",
  "gpt-4",
  "gpt-4-1106-preview",
  "gpt-4-vision-preview",
  "gpt-4-0125-preview",
  "gpt-4-turbo-preview",
  "gpt-4-turbo",
  "gpt-4o",
  "gpt-3.5-turbo-0125",
  "gpt-3.5-turbo-1106"
];
var variableType = ZodEnum.create([
  "any",
  "string",
  "number",
  "boolean",
  "object",
  "pattern",
  "date",
  "array",
  "target",
  "time",
  "enum"
]);
var variable = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "variable", params: __spreadValues({ type: (opts == null ? void 0 : opts.type) || "any" }, opts == null ? void 0 : opts.params) }), "variable");
var conversation = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "conversation", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "conversation");
var user = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "user", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "user");
var message = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "message", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "message");
var agent = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "agent", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "agent");
var event = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "event", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "event");
var table = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "table", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "table");
var tablerow = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "tablerow", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "tablerow");
var intent = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "intent", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "intent");
var aimodel = /* @__PURE__ */ __name(() => ZodEnum.create(AI_MODELS).displayAs({ id: "dropdown", params: {} }), "aimodel");
var datasource = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "datasource", params: __spreadValues({}, opts) }), "datasource");
var knowledgebase = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "knowledgebase", params: __spreadValues({}, opts) }), "knowledgebase");

// src/z/z.ts
var late = {
  object: ZodObject2.lazycreate
};
var instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject2.create;
var strictObjectType = ZodObject2.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var refType = ZodRef.create;
var readonlyType = ZodReadonly.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var defaultType = ZodDefault.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var templateLiteralType = ZodTemplateLiteral.create;
var ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
var fromJsonSchema = ZodType.fromJsonSchema;
var fromObject = ZodType.fromObject;
var coerce = {
  string: (arg) => ZodString.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  number: (arg) => ZodNumber.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  boolean: (arg) => ZodBoolean.create(__spreadProps(__spreadValues({}, arg), {
    coerce: true
  })),
  bigint: (arg) => ZodBigInt.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  date: (arg) => ZodDate.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  templateLiteral: (arg) => ZodTemplateLiteral.create(__spreadProps(__spreadValues({}, arg), {
    coerce: true
  }))
};
var NEVER = INVALID;

// src/z/index.ts
var z_default = z_exports;

// src/transforms/json-schema-to-zui/parsers/parseAnyOf.ts
var parseAnyOf = /* @__PURE__ */ __name((schema, refs) => {
  return schema.anyOf.length ? schema.anyOf.length === 1 ? parseSchema(schema.anyOf[0], __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "anyOf", 0]
  })) : `z.union([${schema.anyOf.map((schema2, i) => parseSchema(schema2, __spreadProps(__spreadValues({}, refs), { path: [...refs.path, "anyOf", i] }))).join(", ")}])` : `z.any()`;
}, "parseAnyOf");

// src/transforms/json-schema-to-zui/parsers/parseBoolean.ts
var parseBoolean = /* @__PURE__ */ __name((_schema) => {
  var _a;
  if ((_a = _schema[zuiKey]) == null ? void 0 : _a.coerce) {
    return "z.coerce.boolean()";
  }
  return "z.boolean()";
}, "parseBoolean");

// src/transforms/json-schema-to-zui/parsers/parseDefault.ts
var parseDefault = /* @__PURE__ */ __name((_schema) => {
  return "z.any()";
}, "parseDefault");

// src/transforms/json-schema-to-zui/parsers/parseMultipleType.ts
var parseMultipleType = /* @__PURE__ */ __name((schema, refs) => {
  return `z.union([${schema.type.map((type) => parseSchema(__spreadProps(__spreadValues({}, schema), { type }), refs)).join(", ")}])`;
}, "parseMultipleType");

// src/transforms/json-schema-to-zui/parsers/parseNot.ts
var parseNot = /* @__PURE__ */ __name((schema, refs) => {
  return `z.any().refine((value) => !${parseSchema(schema.not, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "not"]
  }))}.safeParse(value).success, "Invalid input: Should NOT be valid against schema")`;
}, "parseNot");

// src/transforms/json-schema-to-zui/parsers/parseNull.ts
var parseNull = /* @__PURE__ */ __name((_schema) => {
  return "z.null()";
}, "parseNull");

// src/transforms/json-schema-to-zui/utils.ts
var half = /* @__PURE__ */ __name((arr) => {
  return [arr.slice(0, arr.length / 2), arr.slice(arr.length / 2)];
}, "half");
var omit = /* @__PURE__ */ __name((obj, ...keys) => Object.keys(obj).reduce((acc, key) => {
  if (!keys.includes(key)) {
    acc[key] = obj[key];
  }
  return acc;
}, {}), "omit");
function withMessage(schema, key, get) {
  var _a;
  const value = schema[key];
  let r = "";
  if (value !== void 0) {
    const got = get({ value, json: JSON.stringify(value) });
    if (got) {
      const opener = got[0];
      const prefix = got.length === 3 ? got[1] : "";
      const closer = got.length === 3 ? got[2] : got[1];
      r += opener;
      if (((_a = schema.errorMessage) == null ? void 0 : _a[key]) !== void 0) {
        r += prefix + JSON.stringify(schema.errorMessage[key]);
      }
      r;
      r += closer;
    }
  }
  return r;
}
__name(withMessage, "withMessage");

// src/transforms/json-schema-to-zui/parsers/parseAllOf.ts
var originalIndex = Symbol("Original index");
var ensureOriginalIndex = /* @__PURE__ */ __name((arr) => {
  let newArr = [];
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    if (typeof item === "boolean") {
      newArr.push(item ? { [originalIndex]: i } : { [originalIndex]: i, not: {} });
    } else if (originalIndex in item) {
      return arr;
    } else {
      newArr.push(__spreadProps(__spreadValues({}, item), { [originalIndex]: i }));
    }
  }
  return newArr;
}, "ensureOriginalIndex");
function parseAllOf(schema, refs) {
  if (schema.allOf.length === 0) {
    return "z.never()";
  } else if (schema.allOf.length === 1) {
    const item = schema.allOf[0];
    return parseSchema(item, __spreadProps(__spreadValues({}, refs), {
      path: [...refs.path, "allOf", item[originalIndex]]
    }));
  } else {
    const [left, right] = half(ensureOriginalIndex(schema.allOf));
    return `z.intersection(${parseAllOf({ allOf: left }, refs)}, ${parseAllOf(
      {
        allOf: right
      },
      refs
    )})`;
  }
}
__name(parseAllOf, "parseAllOf");

// src/transforms/json-schema-to-zui/parsers/parseArray.ts
var parseArray = /* @__PURE__ */ __name((schema, refs) => {
  if (Array.isArray(schema.items)) {
    return `z.tuple([${schema.items.map((v, i) => parseSchema(v, __spreadProps(__spreadValues({}, refs), { path: [...refs.path, "items", i] })))}])`;
  }
  let r = !schema.items ? "z.array(z.any())" : `z.array(${parseSchema(schema.items, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "items"]
  }))})`;
  r += withMessage(schema, "minItems", ({ json }) => [`.min(${json}`, ", ", ")"]);
  r += withMessage(schema, "maxItems", ({ json }) => [`.max(${json}`, ", ", ")"]);
  return r;
}, "parseArray");

// src/transforms/json-schema-to-zui/parsers/parseConst.ts
var parseConst = /* @__PURE__ */ __name((schema) => {
  return `z.literal(${JSON.stringify(schema.const)})`;
}, "parseConst");

// src/transforms/json-schema-to-zui/parsers/parseEnum.ts
var parseEnum = /* @__PURE__ */ __name((schema) => {
  if (schema.enum.length === 0) {
    return "z.never()";
  } else if (schema.enum.length === 1) {
    return `z.literal(${JSON.stringify(schema.enum[0])})`;
  } else if (schema.enum.every((x) => typeof x === "string")) {
    return `z.enum([${schema.enum.map((x) => JSON.stringify(x))}])`;
  } else {
    return `z.union([${schema.enum.map((x) => `z.literal(${JSON.stringify(x)})`).join(", ")}])`;
  }
}, "parseEnum");

// src/transforms/json-schema-to-zui/parsers/parseIfThenElse.ts
var parseIfThenElse = /* @__PURE__ */ __name((schema, refs) => {
  const $if = parseSchema(schema.if, __spreadProps(__spreadValues({}, refs), { path: [...refs.path, "if"] }));
  const $then = parseSchema(schema.then, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "then"]
  }));
  const $else = parseSchema(schema.else, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "else"]
  }));
  return `z.union([${$then}, ${$else}]).superRefine((value,ctx) => {
  const result = ${$if}.safeParse(value).success
    ? ${$then}.safeParse(value)
    : ${$else}.safeParse(value);
  if (!result.success) {
    result.error.errors.forEach((error) => ctx.addIssue(error))
  }
})`;
}, "parseIfThenElse");

// src/transforms/json-schema-to-zui/parsers/parseNumber.ts
var parseNumber = /* @__PURE__ */ __name((schema) => {
  var _a;
  let r = "z.number()";
  if ((_a = schema[zuiKey]) == null ? void 0 : _a.coerce) {
    r = "z.coerce.number()";
  }
  if (schema.type === "integer") {
    r += withMessage(schema, "type", () => [".int(", ")"]);
  } else {
    r += withMessage(schema, "format", ({ value }) => {
      if (value === "int64") {
        return [".int(", ")"];
      }
    });
  }
  r += withMessage(schema, "multipleOf", ({ value, json }) => {
    if (value === 1) {
      if (r.startsWith("z.number().int(")) {
        return;
      }
      return [".int(", ")"];
    }
    return [`.multipleOf(${json}`, ", ", ")"];
  });
  if (typeof schema.minimum === "number") {
    if (schema.exclusiveMinimum === true) {
      r += withMessage(schema, "minimum", ({ json }) => [`.gt(${json}`, ", ", ")"]);
    } else {
      r += withMessage(schema, "minimum", ({ json }) => [`.gte(${json}`, ", ", ")"]);
    }
  } else if (typeof schema.exclusiveMinimum === "number") {
    r += withMessage(schema, "exclusiveMinimum", ({ json }) => [`.gt(${json}`, ", ", ")"]);
  }
  if (typeof schema.maximum === "number") {
    if (schema.exclusiveMaximum === true) {
      r += withMessage(schema, "maximum", ({ json }) => [`.lt(${json}`, ", ", ")"]);
    } else {
      r += withMessage(schema, "maximum", ({ json }) => [`.lte(${json}`, ", ", ")"]);
    }
  } else if (typeof schema.exclusiveMaximum === "number") {
    r += withMessage(schema, "exclusiveMaximum", ({ json }) => [`.lt(${json}`, ", ", ")"]);
  }
  return r;
}, "parseNumber");

// src/transforms/json-schema-to-zui/parsers/parseOneOf.ts
var parseOneOf = /* @__PURE__ */ __name((schema, refs) => {
  return schema.oneOf.length ? schema.oneOf.length === 1 ? parseSchema(schema.oneOf[0], __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "oneOf", 0]
  })) : `z.any().superRefine((x, ctx) => {
    const schemas = [${schema.oneOf.map(
    (schema2, i) => parseSchema(schema2, __spreadProps(__spreadValues({}, refs), {
      path: [...refs.path, "oneOf", i]
    }))
  ).join(", ")}];
    const errors = schemas.reduce(
      (errors: z.ZodError[], schema) =>
        ((result) => ("error" in result ? [...errors, result.error] : errors))(
          schema.safeParse(x)
        ),
      []
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })` : "z.any()";
}, "parseOneOf");

// src/transforms/json-schema-to-zui/parsers/parseObject.ts
function parseObject(objectSchema, refs) {
  let properties = void 0;
  if (objectSchema.properties) {
    if (!Object.keys(objectSchema.properties).length) {
      properties = "z.object({})";
    } else {
      properties = "z.object({ ";
      properties += Object.keys(objectSchema.properties).map((key) => {
        const propSchema = objectSchema.properties[key];
        const result = `${JSON.stringify(key)}: ${parseSchema(propSchema, __spreadProps(__spreadValues({}, refs), {
          path: [...refs.path, "properties", key]
        }))}`;
        const hasDefault = typeof propSchema === "object" && propSchema.default !== void 0 || typeof objectSchema.default === "object" && objectSchema.default !== null && key in objectSchema.default;
        const required = Array.isArray(objectSchema.required) ? objectSchema.required.includes(key) : typeof propSchema === "object" && propSchema.required === true;
        const optional = !hasDefault && !required;
        return optional ? `${result}.optional()` : result;
      }).join(", ");
      properties += " })";
    }
  }
  const additionalProperties = objectSchema.additionalProperties !== void 0 ? parseSchema(objectSchema.additionalProperties, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "additionalProperties"]
  })) : void 0;
  let patternProperties = void 0;
  if (objectSchema.patternProperties) {
    const parsedPatternProperties = Object.fromEntries(
      Object.entries(objectSchema.patternProperties).map(([key, value]) => {
        return [
          key,
          parseSchema(value, __spreadProps(__spreadValues({}, refs), {
            path: [...refs.path, "patternProperties", key]
          }))
        ];
      }, {})
    );
    patternProperties = "";
    if (properties) {
      if (additionalProperties) {
        patternProperties += `.catchall(z.union([${[
          ...Object.values(parsedPatternProperties),
          additionalProperties
        ].join(", ")}]))`;
      } else if (Object.keys(parsedPatternProperties).length > 1) {
        patternProperties += `.catchall(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
      } else {
        patternProperties += `.catchall(${Object.values(parsedPatternProperties)})`;
      }
    } else {
      if (additionalProperties) {
        patternProperties += `z.record(z.union([${[
          ...Object.values(parsedPatternProperties),
          additionalProperties
        ].join(", ")}]))`;
      } else if (Object.keys(parsedPatternProperties).length > 1) {
        patternProperties += `z.record(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
      } else {
        patternProperties += `z.record(${Object.values(parsedPatternProperties)})`;
      }
    }
    patternProperties += ".superRefine((value, ctx) => {\n";
    patternProperties += "for (const key in value) {\n";
    if (additionalProperties) {
      if (objectSchema.properties) {
        patternProperties += `let evaluated = [${Object.keys(objectSchema.properties).map((key) => JSON.stringify(key)).join(", ")}].includes(key)
`;
      } else {
        patternProperties += `let evaluated = false
`;
      }
    }
    for (const key in objectSchema.patternProperties) {
      patternProperties += "if (key.match(new RegExp(" + JSON.stringify(key) + "))) {\n";
      if (additionalProperties) {
        patternProperties += "evaluated = true\n";
      }
      patternProperties += "const result = " + parsedPatternProperties[key] + ".safeParse(value[key])\n";
      patternProperties += "if (!result.success) {\n";
      patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: Key matching regex /\${key}/ must match schema\`,
          params: {
            issues: result.error.issues
          }
        })
`;
      patternProperties += "}\n";
      patternProperties += "}\n";
    }
    if (additionalProperties) {
      patternProperties += "if (!evaluated) {\n";
      patternProperties += "const result = " + additionalProperties + ".safeParse(value[key])\n";
      patternProperties += "if (!result.success) {\n";
      patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: must match catchall schema\`,
          params: {
            issues: result.error.issues
          }
        })
`;
      patternProperties += "}\n";
      patternProperties += "}\n";
    }
    patternProperties += "}\n";
    patternProperties += "})";
  }
  let output4 = properties ? patternProperties ? properties + patternProperties : additionalProperties ? additionalProperties === "z.never()" ? properties + ".strict()" : properties + `.catchall(${additionalProperties})` : properties : patternProperties ? patternProperties : additionalProperties ? `z.record(${additionalProperties})` : "z.record(z.any())";
  if (its.an.anyOf(objectSchema)) {
    output4 += `.and(${parseAnyOf(
      __spreadProps(__spreadValues({}, objectSchema), {
        anyOf: objectSchema.anyOf.map(
          (x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? __spreadProps(__spreadValues({}, x), { type: "object" }) : x
        )
      }),
      refs
    )})`;
  }
  if (its.a.oneOf(objectSchema)) {
    output4 += `.and(${parseOneOf(
      __spreadProps(__spreadValues({}, objectSchema), {
        oneOf: objectSchema.oneOf.map(
          (x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? __spreadProps(__spreadValues({}, x), { type: "object" }) : x
        )
      }),
      refs
    )})`;
  }
  if (its.an.allOf(objectSchema)) {
    output4 += `.and(${parseAllOf(
      __spreadProps(__spreadValues({}, objectSchema), {
        allOf: objectSchema.allOf.map(
          (x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? __spreadProps(__spreadValues({}, x), { type: "object" }) : x
        )
      }),
      refs
    )})`;
  }
  return output4;
}
__name(parseObject, "parseObject");

// src/transforms/json-schema-to-zui/parsers/parseString.ts
var parseString = /* @__PURE__ */ __name((schema) => {
  var _a;
  let r = "z.string()";
  if ((_a = schema[zuiKey]) == null ? void 0 : _a.coerce) {
    if (schema.format === "date-time") {
      return "z.coerce.date()";
    }
    r = "z.coerce.string()";
  }
  r += withMessage(schema, "format", ({ value }) => {
    switch (value) {
      case "email":
        return [".email(", ")"];
      case "ip":
        return [".ip(", ")"];
      case "ipv4":
        return ['.ip({ version: "v4"', ", message: ", " })"];
      case "ipv6":
        return ['.ip({ version: "v6"', ", message: ", " })"];
      case "uri":
        return [".url(", ")"];
      case "uuid":
        return [".uuid(", ")"];
      case "date-time":
        return [".datetime(", ")"];
    }
  });
  r += withMessage(schema, "pattern", ({ json }) => [`.regex(new RegExp(${json})`, ", ", ")"]);
  r += withMessage(schema, "minLength", ({ json }) => [`.min(${json}`, ", ", ")"]);
  r += withMessage(schema, "maxLength", ({ json }) => [`.max(${json}`, ", ", ")"]);
  return r;
}, "parseString");

// src/transforms/json-schema-to-zui/parsers/parseNullable.ts
var parseNullable = /* @__PURE__ */ __name((schema, refs) => {
  return `${parseSchema(omit(schema, "nullable"), refs, true)}.nullable()`;
}, "parseNullable");

// src/transforms/json-schema-to-zui/parsers/parseRef.ts
var parseRef = /* @__PURE__ */ __name((schema) => {
  return `z.ref('${schema.$ref}')`;
}, "parseRef");

// src/transforms/json-schema-to-zui/parsers/parseDiscriminator.ts
var parseDiscriminator = /* @__PURE__ */ __name((schema, refs) => {
  var _a, _b;
  if (schema.oneOf.length <= 1 || !((_a = schema.discriminator) == null ? void 0 : _a.propertyName)) {
    return parseOneOf(schema, refs);
  }
  const schemas = schema.oneOf.map(
    (schema2, i) => parseSchema(schema2, __spreadProps(__spreadValues({}, refs), {
      path: [...refs.path, "oneOf", i]
    }))
  );
  return `z.discriminatedUnion("${(_b = schema.discriminator) == null ? void 0 : _b.propertyName}", [${schemas.join(", ")}])`;
}, "parseDiscriminator");

// src/transforms/json-schema-to-zui/parsers/parseSchema.ts
var parseSchema = /* @__PURE__ */ __name((schema, refs = { seen: /* @__PURE__ */ new Map(), path: [] }, blockMeta) => {
  if (typeof schema !== "object")
    return schema ? "z.any()" : "z.never()";
  if (refs.parserOverride) {
    const custom2 = refs.parserOverride(schema, refs);
    if (typeof custom2 === "string") {
      return custom2;
    }
  }
  let seen = refs.seen.get(schema);
  if (seen) {
    if (seen.r !== void 0) {
      return seen.r;
    }
    if (refs.depth === void 0 || seen.n >= refs.depth) {
      return "z.any()";
    }
    seen.n += 1;
  } else {
    seen = { r: void 0, n: 0 };
    refs.seen.set(schema, seen);
  }
  let parsed = selectParser2(schema, refs);
  if (!blockMeta) {
    parsed = addMeta2(schema, parsed);
    if (!refs.withoutDefaults) {
      parsed = addDefaults(schema, parsed);
    }
  }
  seen.r = parsed;
  return parsed;
}, "parseSchema");
var addMeta2 = /* @__PURE__ */ __name((schema, parsed) => {
  if (schema.description) {
    parsed += `.describe(${JSON.stringify(schema.description)})`;
  }
  return parsed;
}, "addMeta");
var addDefaults = /* @__PURE__ */ __name((schema, parsed) => {
  if (schema.default !== void 0) {
    parsed += `.default(${JSON.stringify(schema.default)})`;
  }
  return parsed;
}, "addDefaults");
var selectParser2 = /* @__PURE__ */ __name((schema, refs) => {
  if (its.a.nullable(schema)) {
    return parseNullable(schema, refs);
  } else if (its.an.object(schema)) {
    return parseObject(schema, refs);
  } else if (its.an.array(schema)) {
    return parseArray(schema, refs);
  } else if (its.an.anyOf(schema)) {
    return parseAnyOf(schema, refs);
  } else if (its.an.allOf(schema)) {
    return parseAllOf(schema, refs);
  } else if (its.a.discriminator(schema)) {
    return parseDiscriminator(schema, refs);
  } else if (its.a.oneOf(schema)) {
    return parseOneOf(schema, refs);
  } else if (its.a.not(schema)) {
    return parseNot(schema, refs);
  } else if (its.an.enum(schema)) {
    return parseEnum(schema);
  } else if (its.a.const(schema)) {
    return parseConst(schema);
  } else if (its.a.multipleType(schema)) {
    return parseMultipleType(schema, refs);
  } else if (its.a.primitive(schema, "string")) {
    return parseString(schema);
  } else if (its.a.primitive(schema, "number") || its.a.primitive(schema, "integer")) {
    return parseNumber(schema);
  } else if (its.a.primitive(schema, "boolean")) {
    return parseBoolean(schema);
  } else if (its.a.primitive(schema, "null")) {
    return parseNull(schema);
  } else if (its.a.conditional(schema)) {
    return parseIfThenElse(schema, refs);
  } else if (its.a.ref(schema)) {
    return parseRef(schema);
  } else {
    return parseDefault(schema);
  }
}, "selectParser");
var its = {
  an: {
    object: (x) => x.type === "object",
    array: (x) => x.type === "array",
    anyOf: (x) => x.anyOf !== void 0,
    allOf: (x) => x.allOf !== void 0,
    enum: (x) => x.enum !== void 0
  },
  a: {
    nullable: (x) => x.nullable === true,
    multipleType: (x) => Array.isArray(x.type),
    not: (x) => x.not !== void 0,
    const: (x) => x.const !== void 0,
    primitive: (x, p) => x.type === p,
    conditional: (x) => Boolean("if" in x && x.if && "then" in x && "else" in x && x.then && x.else),
    discriminator: (x) => {
      var _a;
      return x.oneOf !== void 0 && ((_a = x.discriminator) == null ? void 0 : _a.propertyName) !== void 0;
    },
    oneOf: (x) => x.oneOf !== void 0,
    ref: (x) => x.$ref !== void 0
  }
};

// src/transforms/common/eval-zui-string.ts
var _InvalidZuiStringError = class _InvalidZuiStringError extends Error {
  constructor(zuiString) {
    super(`String "${zuiString}" does not evaluate to a Zod type`);
    this.zuiString = zuiString;
  }
};
__name(_InvalidZuiStringError, "InvalidZuiStringError");
var InvalidZuiStringError = _InvalidZuiStringError;
var evalZuiString = /* @__PURE__ */ __name((zuiString) => {
  const result = new Function("z", `return ${zuiString}`)(z_default);
  if (!(result instanceof z_default.ZodType)) {
    throw new InvalidZuiStringError(zuiString);
  }
  return result;
}, "evalZuiString");

// src/transforms/json-schema-to-zui/index.ts
var jsonSchemaToZodStr = /* @__PURE__ */ __name((schema) => {
  return parseSchema(schema, {
    seen: /* @__PURE__ */ new Map(),
    path: []
  });
}, "jsonSchemaToZodStr");
var jsonSchemaToZod = /* @__PURE__ */ __name((schema) => {
  let code = jsonSchemaToZodStr(schema);
  code = code.replaceAll("errors: z.ZodError[]", "errors");
  return evalZuiString(code);
}, "jsonSchemaToZod");
var applyZuiPropsRecursively = /* @__PURE__ */ __name((zodField, jsonSchemaField) => {
  var _a, _b;
  if (jsonSchemaField[zuiKey] && zodField._def) {
    zodField._def[zuiKey] = jsonSchemaField[zuiKey];
  }
  if (((_a = zodField._def) == null ? void 0 : _a.typeName) === "ZodObject" && jsonSchemaField.type === "object" && jsonSchemaField.properties) {
    Object.entries(jsonSchemaField.properties).forEach(([key, nestedField]) => {
      const shape = typeof zodField._def.shape === "function" ? zodField._def.shape() : zodField._def.shape;
      if (shape[key]) {
        applyZuiPropsRecursively(shape[key], nestedField);
      }
    });
  }
  if (((_b = zodField._def) == null ? void 0 : _b.typeName) === "ZodRecord" && jsonSchemaField.type === "object" && jsonSchemaField.additionalProperties) {
    applyZuiPropsRecursively(zodField._def.valueType, jsonSchemaField.additionalProperties);
  }
  if (jsonSchemaField.type === "array" && jsonSchemaField.items) {
    const items = jsonSchemaField.items;
    if (typeof items === "object" && !Array.isArray(items)) {
      const arrayShape = zodField._def.type;
      if (arrayShape) {
        applyZuiPropsRecursively(arrayShape, items);
      }
    } else if (Array.isArray(items)) {
      items.forEach((item, index) => {
        const def = zodField._def;
        if (def.typeName === z_exports.ZodFirstPartyTypeKind.ZodTuple) {
          applyZuiPropsRecursively(def.items[index], item);
        }
      });
    }
  }
}, "applyZuiPropsRecursively");
var jsonSchemaToZui = /* @__PURE__ */ __name((schema) => {
  const zodSchema = jsonSchemaToZod(schema);
  applyZuiPropsRecursively(zodSchema, schema);
  return zodSchema;
}, "jsonSchemaToZui");

// src/ui/Form.tsx
var import_react5 = __toESM(require("react"), 1);

// src/ui/ErrorBoundary.tsx
var import_react3 = __toESM(require("react"), 1);
var _ErrorBoundary = class _ErrorBoundary extends import_react3.Component {
  constructor() {
    super(...arguments);
    this.state = {
      hasError: false,
      error: null
    };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }
  render() {
    if (this.state.hasError && this.props.fallback) {
      return /* @__PURE__ */ import_react3.default.createElement(this.props.fallback, { error: this.state.error, schema: this.props.fieldSchema });
    }
    return this.props.children;
  }
};
__name(_ErrorBoundary, "ErrorBoundary");
var ErrorBoundary = _ErrorBoundary;
function withErrorBoundary(Component2, fallback) {
  return (props) => /* @__PURE__ */ import_react3.default.createElement(ErrorBoundary, { fallback, fieldSchema: props.fieldSchema, path: props.path }, /* @__PURE__ */ import_react3.default.createElement(Component2, __spreadValues({}, props)));
}
__name(withErrorBoundary, "withErrorBoundary");

// src/ui/ElementRenderer.tsx
var import_react4 = __toESM(require("react"), 1);
var FormElementRenderer = /* @__PURE__ */ __name((_a) => {
  var _b = _a, {
    components,
    fieldSchema,
    path,
    required,
    fallback
  } = _b, childProps = __objRest(_b, [
    "components",
    "fieldSchema",
    "path",
    "required",
    "fallback"
  ]);
  var _a2, _b2;
  const { formData, disabled, hidden, handlePropertyChange, addArrayItem, removeArrayItem, formErrors, formValid } = useFormData(fieldSchema, path);
  const data = (0, import_react4.useMemo)(() => getPathData(formData, path), [formData, path]);
  const componentMeta = (0, import_react4.useMemo)(() => resolveComponent(components, fieldSchema), [fieldSchema, components]);
  const { discriminator, discriminatedSchema, discriminatorValue } = useDiscriminator(fieldSchema, path);
  if (!componentMeta) {
    return null;
  }
  if (hidden === true) {
    return null;
  }
  const { Component: _component, type } = componentMeta;
  const baseProps = {
    type,
    componentID: componentMeta.id,
    scope: path.join("."),
    context: {
      path,
      readonly: false,
      formData,
      formErrors,
      formValid,
      updateForm: handlePropertyChange,
      updateFormData: (data2) => handlePropertyChange([], data2)
    },
    onChange: (data2) => handlePropertyChange(path, data2),
    disabled,
    errors: (formErrors == null ? void 0 : formErrors.filter((e) => e.path === path)) || [],
    label: ((_a2 = fieldSchema[zuiKey]) == null ? void 0 : _a2.title) || formatTitle(((_b2 = path[path.length - 1]) == null ? void 0 : _b2.toString()) || ""),
    params: componentMeta.params,
    schema: fieldSchema,
    zuiProps: fieldSchema[zuiKey]
  };
  if (fieldSchema.type === "array" && type === "array") {
    const Component3 = _component;
    const schema = baseProps.schema;
    const dataArray = Array.isArray(data) ? data : typeof data === "object" ? data : [];
    const props2 = __spreadValues(__spreadProps(__spreadValues({}, baseProps), {
      type,
      schema,
      data: dataArray,
      addItem: (data2) => addArrayItem(path, data2),
      removeItem: (index) => removeArrayItem(path, index)
    }), childProps);
    if (Array.isArray(fieldSchema.items)) {
      return null;
    }
    return /* @__PURE__ */ import_react4.default.createElement(Component3, __spreadProps(__spreadValues({ key: baseProps.scope }, props2), { isArrayChild: props2.isArrayChild }), Array.isArray(props2.data) ? props2.data.map((_, index) => {
      const childPath = [...path, index.toString()];
      return /* @__PURE__ */ import_react4.default.createElement(
        ErrorBoundary,
        {
          key: childPath.join("."),
          fallback,
          fieldSchema: fieldSchema.items,
          path: childPath
        },
        /* @__PURE__ */ import_react4.default.createElement(
          FormElementRenderer,
          {
            key: childPath.join("."),
            components,
            fieldSchema: fieldSchema.items,
            path: childPath,
            required,
            isArrayChild: true,
            index,
            removeSelf: () => removeArrayItem(path, index),
            fallback
          }
        )
      );
    }) : []);
  }
  if (fieldSchema.type === "object" && type === "object" && fieldSchema.properties) {
    const Component3 = _component;
    const props2 = __spreadValues(__spreadProps(__spreadValues({}, baseProps), {
      type,
      schema: baseProps.schema,
      data: data || {}
    }), childProps);
    return /* @__PURE__ */ import_react4.default.createElement(Component3, __spreadProps(__spreadValues({ key: baseProps.scope }, props2), { isArrayChild: props2.isArrayChild }), Object.entries(fieldSchema.properties).map(([fieldName, childSchema]) => {
      var _a3;
      const childPath = [...path, fieldName];
      return /* @__PURE__ */ import_react4.default.createElement(ErrorBoundary, { key: childPath.join("."), fallback, fieldSchema: childSchema, path: childPath }, /* @__PURE__ */ import_react4.default.createElement(
        FormElementRenderer,
        {
          key: childPath.join("."),
          components,
          fieldSchema: childSchema,
          path: childPath,
          required: ((_a3 = fieldSchema.required) == null ? void 0 : _a3.includes(fieldName)) || false,
          isArrayChild: false,
          fallback
        }
      ));
    }));
  }
  if (type === "discriminatedUnion") {
    const Component3 = _component;
    const props2 = __spreadValues(__spreadProps(__spreadValues({}, baseProps), {
      type,
      schema: baseProps.schema,
      data: data || {},
      discriminatorKey: (discriminator == null ? void 0 : discriminator.key) || null,
      discriminatorLabel: formatTitle((discriminator == null ? void 0 : discriminator.key) || "Unknown"),
      discriminatorOptions: (discriminator == null ? void 0 : discriminator.values) || null,
      discriminatorValue,
      setDiscriminator: (disc) => {
        if (!(discriminator == null ? void 0 : discriminator.key)) {
          console.warn("No discriminator key found, cannot set discriminator");
          return;
        }
        handlePropertyChange(path, { [discriminator.key]: disc });
      }
    }), childProps);
    return /* @__PURE__ */ import_react4.default.createElement(Component3, __spreadProps(__spreadValues({ key: baseProps.scope }, props2), { isArrayChild: props2.isArrayChild }), discriminatedSchema && /* @__PURE__ */ import_react4.default.createElement(ErrorBoundary, { key: path.join("."), fallback, fieldSchema: discriminatedSchema, path }, /* @__PURE__ */ import_react4.default.createElement(
      FormElementRenderer,
      {
        components,
        fieldSchema: discriminatedSchema,
        path,
        required,
        isArrayChild: false,
        fallback
      }
    )));
  }
  const Component2 = _component;
  const props = __spreadValues(__spreadProps(__spreadValues({}, baseProps), {
    type,
    schema: baseProps.schema,
    config: {},
    required,
    data,
    description: fieldSchema.description
  }), childProps);
  return /* @__PURE__ */ import_react4.default.createElement(Component2, __spreadValues({}, props));
}, "FormElementRenderer");

// src/ui/Form.tsx
var ZuiForm = /* @__PURE__ */ __name(({
  schema,
  components,
  onChange,
  value,
  disableValidation,
  fallback,
  dataTransform,
  onValidation
}) => {
  const [formData, setFormData] = (0, import_react5.useState)(value);
  (0, import_react5.useEffect)(() => {
    onChange(formData);
  }, [formData]);
  (0, import_react5.useEffect)(() => {
    const defaults = getDefaultValues(schema);
    setFormData((prev) => deepMerge(defaults, prev));
  }, [JSON.stringify(schema), setFormData]);
  return /* @__PURE__ */ import_react5.default.createElement(
    FormDataProvider,
    {
      formData,
      setFormData,
      formSchema: schema,
      disableValidation: disableValidation || false,
      dataTransform,
      onValidation
    },
    /* @__PURE__ */ import_react5.default.createElement(ErrorBoundary, { fallback, fieldSchema: schema, path: [] }, /* @__PURE__ */ import_react5.default.createElement(
      FormElementRenderer,
      {
        components,
        fieldSchema: schema,
        path: [],
        fallback,
        required: true,
        isArrayChild: false
      }
    ))
  );
}, "ZuiForm");

// src/ui/component-definitions.ts
var defaultComponentDefinitions = {
  string: {},
  number: {
    slider: {
      id: "slider",
      params: z_default.object({})
    }
  },
  boolean: {
    switch: {
      id: "switch",
      params: z_default.object({})
    }
  },
  array: {},
  object: {},
  discriminatedUnion: {}
};

// src/index.ts
var transforms = {
  jsonSchemaToZui,
  zuiToJsonSchema,
  objectToZui,
  toTypescript,
  toTypescriptSchema
};
//# sourceMappingURL=index.cjs.map