{
  "version": 3,
  "sources": ["../src/index.ts", "../src/message.ts", "../src/zui.ts", "../src/const.ts", "../src/serve.ts", "../src/log.ts", "../src/utils/record-utils.ts", "../src/utils/array-utils.ts", "../src/integration/definition/branded-schema.ts", "../src/integration/definition/index.ts", "../src/integration/server/index.ts", "../src/retry.ts", "../src/integration/client/index.ts", "../src/integration/server/action-metadata.ts", "../src/integration/server/context.ts", "../src/integration/server/logger.ts", "../src/integration/implementation.ts", "../src/bot/definition.ts", "../src/bot/server/index.ts", "../src/bot/client/index.ts", "../src/bot/server/context.ts", "../src/bot/implementation.ts", "../src/interface/definition.ts"],
  "sourcesContent": ["export * as messages from './message'\nexport * from './const'\nexport * from './serve'\nexport * from './zui'\n\nexport {\n  //\n  isApiError,\n  RuntimeError,\n} from '@botpress/client'\n\nexport {\n  DefaultIntegration,\n  IntegrationDefinition,\n  IntegrationDefinitionProps,\n  IntegrationImplementation as Integration,\n  IntegrationImplementationProps as IntegrationProps,\n  IntegrationLogger,\n  IntegrationSpecificClient,\n  TagDefinition,\n  ConfigurationDefinition,\n  AdditionalConfigurationDefinition,\n  EventDefinition,\n  ChannelDefinition,\n  MessageDefinition,\n  ActionDefinition,\n  StateDefinition,\n  UserDefinition,\n  SecretDefinition,\n  EntityDefinition,\n} from './integration'\n\nexport {\n  /**\n   * @deprecated use Context exported from '.botpress' instead\n   */\n  IntegrationContext,\n} from './integration/server'\n\nexport {\n  DefaultBot,\n  BotDefinition,\n  BotDefinitionProps,\n  BotImplementation as Bot,\n  BotImplementationProps as BotProps,\n  BotSpecificClient,\n  TagDefinition as BotTagDefinition,\n  StateType as BotStateType,\n  StateDefinition as BotStateDefinition,\n  RecurringEventDefinition as BotRecurringEventDefinition,\n  EventDefinition as BotEventDefinition,\n  ConfigurationDefinition as BotConfigurationDefinition,\n  UserDefinition as BotUserDefinition,\n  ConversationDefinition as BotConversationDefinition,\n  MessageDefinition as BotMessageDefinition,\n  ActionDefinition as BotActionDefinition,\n} from './bot'\n\nexport {\n  //\n  InterfaceDeclaration,\n  InterfaceDeclarationProps,\n} from './interface'\n\nexport {\n  //\n  IntegrationPackage,\n  InterfacePackage,\n} from './package'\n", "import { z } from './zui'\n\nconst NonEmptyString = z.string().min(1)\n\nconst textMessageSchema = z.object({\n  text: NonEmptyString,\n})\n\nconst markdownMessageSchema = z.object({\n  markdown: NonEmptyString,\n})\n\nconst imageMessageSchema = z.object({\n  imageUrl: NonEmptyString,\n})\n\nconst audioMessageSchema = z.object({\n  audioUrl: NonEmptyString,\n})\n\nconst videoMessageSchema = z.object({\n  videoUrl: NonEmptyString,\n})\n\nconst fileMessageSchema = z.object({\n  fileUrl: NonEmptyString,\n  title: NonEmptyString.optional(),\n})\n\nconst locationMessageSchema = z.object({\n  latitude: z.number(),\n  longitude: z.number(),\n  address: z.string().optional(),\n  title: z.string().optional(),\n})\n\nconst cardSchema = z.object({\n  title: NonEmptyString,\n  subtitle: NonEmptyString.optional(),\n  imageUrl: NonEmptyString.optional(),\n  actions: z.array(\n    z.object({\n      action: z.enum(['postback', 'url', 'say']),\n      label: NonEmptyString,\n      value: NonEmptyString,\n    })\n  ),\n})\n\nconst choiceSchema = z.object({\n  text: NonEmptyString,\n  options: z.array(\n    z.object({\n      label: NonEmptyString,\n      value: NonEmptyString,\n    })\n  ),\n})\n\nconst carouselSchema = z.object({\n  items: z.array(cardSchema),\n})\n\nconst blocSchema = z.union([\n  z.object({ type: z.literal('text'), payload: textMessageSchema }),\n  z.object({ type: z.literal('markdown'), payload: markdownMessageSchema }),\n  z.object({ type: z.literal('image'), payload: imageMessageSchema }),\n  z.object({ type: z.literal('audio'), payload: audioMessageSchema }),\n  z.object({ type: z.literal('video'), payload: videoMessageSchema }),\n  z.object({ type: z.literal('file'), payload: fileMessageSchema }),\n  z.object({ type: z.literal('location'), payload: locationMessageSchema }),\n])\n\nconst blocsSchema = z.object({\n  items: z.array(blocSchema),\n})\n\n/**\n * @deprecated use `text` instead\n */\nexport const markdown = { schema: markdownMessageSchema }\nexport const defaults = {\n  text: { schema: textMessageSchema },\n  image: { schema: imageMessageSchema },\n  audio: { schema: audioMessageSchema },\n  video: { schema: videoMessageSchema },\n  file: { schema: fileMessageSchema },\n  location: { schema: locationMessageSchema },\n  carousel: { schema: carouselSchema },\n  card: { schema: cardSchema },\n  dropdown: { schema: choiceSchema },\n  choice: { schema: choiceSchema },\n  bloc: { schema: blocsSchema },\n} as const // should use satisfies operator but this works for older versions of TS\n", "import { z } from '@bpinternal/zui'\nexport * from '@bpinternal/zui'\n\nexport type GenericZuiSchema<\n  A extends Record<string, z.ZodTypeAny> = Record<string, z.ZodTypeAny>,\n  R extends z.ZodTypeAny = z.ZodTypeAny\n> = (typeArguments: A) => R\n\nexport default z\n", "export const botIdHeader = 'x-bot-id'\nexport const botUserIdHeader = 'x-bot-user-id'\nexport const integrationIdHeader = 'x-integration-id'\nexport const webhookIdHeader = 'x-webhook-id'\n\nexport const configurationTypeHeader = 'x-bp-configuration-type'\nexport const configurationHeader = 'x-bp-configuration'\nexport const operationHeader = 'x-bp-operation'\nexport const typeHeader = 'x-bp-type'\n", "import { createServer, IncomingMessage, Server } from 'node:http'\nimport { log } from './log'\n\nexport type Request = {\n  body?: string\n  path: string\n  query: string\n  method: string\n  headers: { [key: string]: string | undefined }\n}\n\nexport type Response = {\n  body?: string\n  headers?: { [key: string]: string }\n  status?: number\n}\n\nexport type Handler = (req: Request) => Promise<Response | void>\n\nexport function parseBody<T>(req: Request): T {\n  if (!req.body) {\n    throw new Error('Missing body')\n  }\n  return JSON.parse(req.body)\n}\n\nexport async function serve(\n  handler: Handler,\n  port: number = 8072,\n  callback: (port: number) => void = defaultCallback\n): Promise<Server> {\n  /* eslint-disable @typescript-eslint/no-misused-promises */\n  const server = createServer(async (req, res) => {\n    try {\n      const request = await mapIncomingMessageToRequest(req)\n      if (request.path === '/health') {\n        res.writeHead(200).end('ok')\n        return\n      }\n      const response = await handler(request)\n      res.writeHead(response?.status ?? 200, response?.headers ?? {}).end(response?.body ?? '{}')\n    } catch (e: any) {\n      log.error('Error while handling request', { error: e?.message ?? 'Internal error occured' })\n      res.writeHead(500).end(JSON.stringify({ error: e?.message ?? 'Internal error occured' }))\n    }\n  })\n\n  server.listen(port, () => callback(port))\n  return server\n}\n\nasync function mapIncomingMessageToRequest(incoming: IncomingMessage): Promise<Request> {\n  const body = await readBody(incoming)\n  const headers = {} as Request['headers']\n\n  for (let i = 0; i < incoming.rawHeaders.length; i += 2) {\n    const key = incoming.rawHeaders[i]!.toLowerCase()\n    const value = incoming.rawHeaders[i + 1]!\n    headers[key] = value\n  }\n\n  const url = new URL(\n    incoming.url ?? '',\n    incoming.headers.host ? `http://${incoming.headers.host}` : 'http://botpress.cloud'\n  )\n\n  return {\n    body,\n    path: url.pathname,\n    query: trimPrefix(url.search, '?'),\n    headers,\n    method: incoming.method?.toUpperCase() ?? 'GET',\n  }\n}\n\nfunction trimPrefix(value: string, prefix: string) {\n  return value.indexOf(prefix) === 0 ? value.slice(prefix.length) : value\n}\n\nasync function readBody(incoming: IncomingMessage) {\n  return new Promise<string | undefined>((resolve, reject) => {\n    if (incoming.method !== 'POST' && incoming.method !== 'PUT' && incoming.method !== 'PATCH') {\n      return resolve(undefined)\n    }\n\n    let body = ''\n\n    incoming.on('data', (chunk) => (body += chunk.toString()))\n    incoming.on('error', (e) => reject(e))\n    incoming.on('end', () => resolve(body))\n  })\n}\n\nfunction defaultCallback(port: number) {\n  log.info(`Listening on port ${port}`)\n}\n", "export type Logger = {\n  debug(message: string, metadata?: any): void\n  info(message: string, metadata?: any): void\n  warn(message: string, metadata?: any): void\n  error(message: string, metadata?: any): void\n}\nexport const log: Logger = console\n", "export const pairs = <K extends string, V>(obj: Record<K, V>) => Object.entries(obj) as [K, V][]\nexport const mapValues = <K extends string, V, R>(obj: Record<K, V>, fn: (value: V, key: K) => R): Record<K, R> =>\n  Object.fromEntries(pairs(obj).map(([key, value]) => [key, fn(value, key)])) as Record<K, R>\n", "export const safePush = <T>(arr: T[] | undefined, value: T): T[] => (arr ? [...arr, value] : [value])\n", "import * as utils from '../../utils'\nimport { z } from '../../zui'\n\nconst schemaName = Symbol('schemaName')\n\ntype BaseSchemas = Record<string, z.ZodSchema>\n\nexport type SchemaStoreProps<TSchemas extends BaseSchemas = BaseSchemas> = {\n  [K in keyof TSchemas]: {\n    schema: TSchemas[K]\n  }\n}\n\nexport type BrandedSchema<TSchema extends BaseSchemas[string] = BaseSchemas[string]> = {\n  schema: TSchema\n  [schemaName]: string\n}\n\nexport type SchemaStore<TSchemas extends BaseSchemas = BaseSchemas> = {\n  [K in keyof TSchemas]: BrandedSchema<TSchemas[K]>\n}\n\nexport const createStore = <TSchemas extends BaseSchemas>(\n  props: SchemaStoreProps<TSchemas> | undefined\n): SchemaStore<TSchemas> => {\n  if (!props) {\n    return {} as SchemaStore<TSchemas>\n  }\n  const store: SchemaStore<BaseSchemas> = utils.records.mapValues(props, (e, k) => ({ ...e, [schemaName]: k }))\n  return store as SchemaStore<TSchemas>\n}\n\nexport const isBranded = (schema: BrandedSchema | { schema: z.ZodSchema }): schema is BrandedSchema => {\n  return schemaName in schema && schema[schemaName] !== undefined\n}\n\nexport const getName = (schema: BrandedSchema): string => {\n  return schema[schemaName]\n}\n", "import { InterfacePackage } from '../../package'\nimport * as utils from '../../utils'\nimport { z } from '../../zui'\nimport { SchemaStore, BrandedSchema, createStore, isBranded, getName } from './branded-schema'\nimport { BaseConfig, BaseEvents, BaseActions, BaseChannels, BaseStates, BaseEntities, BaseConfigs } from './generic'\nimport {\n  ConfigurationDefinition,\n  EventDefinition,\n  ChannelDefinition,\n  ActionDefinition,\n  StateDefinition,\n  UserDefinition,\n  SecretDefinition,\n  EntityDefinition,\n  AdditionalConfigurationDefinition,\n} from './types'\n\nexport * from './types'\n\nexport type InterfaceInstance = InterfacePackage & {\n  entities: Record<\n    string,\n    {\n      name: string\n      schema: z.AnyZodObject\n    }\n  >\n}\n\nexport type IntegrationDefinitionProps<\n  TConfig extends BaseConfig = BaseConfig,\n  TConfigs extends BaseConfigs = BaseConfigs,\n  TEvents extends BaseEvents = BaseEvents,\n  TActions extends BaseActions = BaseActions,\n  TChannels extends BaseChannels = BaseChannels,\n  TStates extends BaseStates = BaseStates,\n  TEntities extends BaseEntities = BaseEntities\n> = {\n  name: string\n  version: string\n\n  title?: string\n  description?: string\n  icon?: string\n  readme?: string\n\n  identifier?: {\n    extractScript?: string\n    fallbackHandlerScript?: string\n  }\n\n  configuration?: ConfigurationDefinition<TConfig>\n  configurations?: {\n    [K in keyof TConfigs]: AdditionalConfigurationDefinition<TConfigs[K]>\n  }\n\n  events?: { [K in keyof TEvents]: EventDefinition<TEvents[K]> }\n\n  actions?: {\n    [K in keyof TActions]: ActionDefinition<TActions[K]>\n  }\n\n  channels?: {\n    [K in keyof TChannels]: ChannelDefinition<TChannels[K]>\n  }\n\n  states?: {\n    [K in keyof TStates]: StateDefinition<TStates[K]>\n  }\n\n  user?: UserDefinition\n\n  secrets?: Record<string, SecretDefinition>\n\n  entities?: {\n    [K in keyof TEntities]: EntityDefinition<TEntities[K]>\n  }\n\n  interfaces?: Record<string, InterfaceInstance>\n}\n\ntype EntitiesOfPackage<TPackage extends InterfacePackage> = {\n  [K in keyof TPackage['definition']['entities']]: NonNullable<TPackage['definition']['entities']>[K]['schema']\n}\n\ntype ExtensionBuilderInput<TIntegrationEntities extends BaseEntities> = SchemaStore<TIntegrationEntities>\n\ntype ExtensionBuilderOutput<TInterfaceEntities extends BaseEntities> = {\n  [K in keyof TInterfaceEntities]: BrandedSchema<z.ZodSchema<z.infer<TInterfaceEntities[K]>>>\n}\n\ntype ExtensionBuilder<TIntegrationEntities extends BaseEntities, TInterfaceEntities extends BaseEntities> = (\n  input: ExtensionBuilderInput<TIntegrationEntities>\n) => ExtensionBuilderOutput<TInterfaceEntities>\n\nexport class IntegrationDefinition<\n  TConfig extends BaseConfig = BaseConfig,\n  TConfigs extends BaseConfigs = BaseConfigs,\n  TEvents extends BaseEvents = BaseEvents,\n  TActions extends BaseActions = BaseActions,\n  TChannels extends BaseChannels = BaseChannels,\n  TStates extends BaseStates = BaseStates,\n  TEntities extends BaseEntities = BaseEntities\n> {\n  public readonly name: this['props']['name']\n  public readonly version: this['props']['version']\n  public readonly title: this['props']['title']\n  public readonly description: this['props']['description']\n  public readonly icon: this['props']['icon']\n  public readonly readme: this['props']['readme']\n  public readonly configuration: this['props']['configuration']\n  public readonly configurations: this['props']['configurations']\n  public readonly events: this['props']['events']\n  public readonly actions: this['props']['actions']\n  public readonly channels: this['props']['channels']\n  public readonly states: this['props']['states']\n  public readonly user: this['props']['user']\n  public readonly secrets: this['props']['secrets']\n  public readonly identifier: this['props']['identifier']\n  public readonly entities: this['props']['entities']\n  public readonly interfaces: this['props']['interfaces']\n  public constructor(\n    public readonly props: IntegrationDefinitionProps<\n      TConfig,\n      TConfigs,\n      TEvents,\n      TActions,\n      TChannels,\n      TStates,\n      TEntities\n    >\n  ) {\n    this.name = props.name\n    this.version = props.version\n    this.icon = props.icon\n    this.readme = props.readme\n    this.title = props.title\n    this.identifier = props.identifier\n    this.description = props.description\n    this.configuration = props.configuration\n    this.configurations = props.configurations\n    this.events = props.events\n    this.actions = props.actions\n    this.channels = props.channels\n    this.states = props.states\n    this.user = props.user\n    this.secrets = props.secrets\n    this.entities = props.entities\n    this.interfaces = props.interfaces\n  }\n\n  public extend<P extends InterfacePackage>(\n    interfacePkg: P,\n    builder: ExtensionBuilder<TEntities, EntitiesOfPackage<P>>\n  ): this {\n    const extensionBuilderOutput = builder(createStore(this.entities))\n    const unbrandedEntity = utils.records.pairs(extensionBuilderOutput).find(([_k, e]) => !isBranded(e))\n    if (unbrandedEntity) {\n      // this means the user tried providing a plain schema without referencing an entity from the integration\n      throw new Error(\n        `Cannot extend interface \"${interfacePkg.definition.name}\" with entity \"${unbrandedEntity[0]}\"; the provided schema is not part of the integration's entities.`\n      )\n    }\n\n    const self = this as utils.types.Writable<IntegrationDefinition>\n    self.interfaces ??= {}\n\n    const interfaceTypeArguments = utils.records.mapValues(extensionBuilderOutput, (e) => ({\n      name: getName(e),\n      schema: e.schema as z.AnyZodObject,\n    }))\n\n    const entityNames = Object.values(interfaceTypeArguments).map((e) => e.name)\n\n    const key =\n      entityNames.length === 0\n        ? interfacePkg.definition.name\n        : `${interfacePkg.definition.name}<${entityNames.join(',')}>`\n\n    self.interfaces[key] = {\n      ...interfacePkg,\n      entities: interfaceTypeArguments,\n    }\n\n    return this\n  }\n}\n", "import { isApiError, Client, RuntimeError } from '@botpress/client'\nimport { retryConfig } from '../../retry'\nimport { Request, Response, parseBody } from '../../serve'\nimport { IntegrationSpecificClient } from '../client'\nimport { BaseIntegration } from '../types'\nimport { ActionMetadataStore } from './action-metadata'\nimport { extractContext } from './context'\nimport { integrationLogger } from './logger'\nimport {\n  CommonHandlerProps,\n  IntegrationHandlers,\n  WebhookPayload,\n  ActionPayload,\n  MessagePayload,\n  RegisterPayload,\n  CreateUserPayload,\n  UnregisterPayload,\n  CreateConversationPayload,\n} from './types'\n\nexport * from './types'\nexport * from './logger'\n\ntype ServerProps = CommonHandlerProps<BaseIntegration> & {\n  req: Request\n  instance: IntegrationHandlers<BaseIntegration>\n}\n\nexport const integrationHandler =\n  (instance: IntegrationHandlers<BaseIntegration>) =>\n  async (req: Request): Promise<Response | void> => {\n    const ctx = extractContext(req.headers)\n\n    const vanillaClient = new Client({\n      botId: ctx.botId,\n      integrationId: ctx.integrationId,\n      retry: retryConfig,\n    })\n    const client = new IntegrationSpecificClient<BaseIntegration>(vanillaClient)\n\n    const props = {\n      ctx,\n      req,\n      client,\n      logger: integrationLogger,\n      instance,\n    }\n\n    try {\n      let response: Response | void\n      switch (ctx.operation) {\n        case 'webhook_received':\n          response = await onWebhook(props)\n          break\n        case 'register':\n          response = await onRegister(props)\n          break\n        case 'unregister':\n          response = await onUnregister(props)\n          break\n        case 'message_created':\n          response = await onMessageCreated(props)\n          break\n        case 'action_triggered':\n          response = await onActionTriggered(props)\n          break\n        case 'ping':\n          response = await onPing(props)\n          break\n        case 'create_user':\n          response = await onCreateUser(props)\n          break\n        case 'create_conversation':\n          response = await onCreateConversation(props)\n          break\n        default:\n          throw new Error(`Unknown operation ${ctx.operation}`)\n      }\n      return response ? { ...response, status: response.status ?? 200 } : { status: 200 }\n    } catch (thrown) {\n      if (isApiError(thrown)) {\n        const runtimeError = new RuntimeError(thrown.message, thrown)\n        integrationLogger.forBot().error(runtimeError.message)\n\n        return { status: runtimeError.code, body: JSON.stringify(runtimeError.toJSON()) }\n      }\n\n      // prints the error in the integration logs\n      console.error(thrown)\n\n      const runtimeError = new RuntimeError(\n        'An unexpected error occurred in the integration. Bot owners: Check logs for more informations. Integration owners: throw a RuntimeError to return a custom error message instead.'\n      )\n      integrationLogger.forBot().error(runtimeError.message)\n      return { status: runtimeError.code, body: JSON.stringify(runtimeError.toJSON()) }\n    }\n  }\n\nconst onPing = async (_: ServerProps) => {}\n\nconst onWebhook = async ({ client, ctx, req: incomingRequest, logger, instance }: ServerProps) => {\n  const { req } = parseBody<WebhookPayload>(incomingRequest)\n  return instance.webhook({ client, ctx, req, logger })\n}\n\nconst onRegister = async ({ client, ctx, req, logger, instance }: ServerProps) => {\n  if (!instance.register) {\n    return\n  }\n  const { webhookUrl } = parseBody<RegisterPayload>(req)\n  await instance.register({ client, ctx, webhookUrl, logger })\n}\n\nconst onUnregister = async ({ client, ctx, req, logger, instance }: ServerProps) => {\n  if (!instance.unregister) {\n    return\n  }\n  const { webhookUrl } = parseBody<UnregisterPayload>(req)\n  await instance.unregister({ ctx, webhookUrl, client, logger })\n}\n\nconst onCreateUser = async ({ client, ctx, req, logger, instance }: ServerProps) => {\n  if (!instance.createUser) {\n    return\n  }\n  const { tags } = parseBody<CreateUserPayload<BaseIntegration>>(req)\n  return await instance.createUser({ ctx, client, tags, logger })\n}\n\nconst onCreateConversation = async ({ client, ctx, req, logger, instance }: ServerProps) => {\n  if (!instance.createConversation) {\n    return\n  }\n  const { channel, tags } = parseBody<CreateConversationPayload<BaseIntegration>>(req)\n  return await instance.createConversation({ ctx, client, channel, tags, logger })\n}\n\nconst onMessageCreated = async ({ ctx, req, client, logger, instance }: ServerProps) => {\n  const { conversation, user, type, payload, message } = parseBody<MessagePayload<BaseIntegration, string, string>>(req)\n\n  const channelHandler = instance.channels[conversation.channel]\n\n  if (!channelHandler) {\n    throw new Error(`Channel ${conversation.channel} not found`)\n  }\n\n  const messageHandler = channelHandler.messages[type]\n\n  if (!messageHandler) {\n    throw new Error(`Message of type ${type} not found in channel ${conversation.channel}`)\n  }\n\n  type UpdateMessageProps = Parameters<(typeof client)['updateMessage']>[0]\n  const ack = async ({ tags }: Pick<UpdateMessageProps, 'tags'>) => {\n    await client.updateMessage({\n      id: message.id,\n      tags,\n    })\n  }\n\n  await messageHandler({ ctx, conversation, message, user, type, client, payload, ack, logger })\n}\n\nconst onActionTriggered = async ({ req, ctx, client, logger, instance }: ServerProps) => {\n  const { input, type } = parseBody<ActionPayload<string, any>>(req)\n\n  if (!type) {\n    throw new Error('Missing action type')\n  }\n\n  const action = instance.actions[type]\n\n  if (!action) {\n    throw new Error(`Action ${type} not found`)\n  }\n\n  const metadata = new ActionMetadataStore()\n  const output = await action({ ctx, input, client, type, logger, metadata })\n\n  const response = { output, meta: metadata.toJSON() }\n  return {\n    body: JSON.stringify(response),\n  }\n}\n", "import { RetryConfig, axiosRetry } from '@botpress/client'\n\nexport const retryConfig: RetryConfig = {\n  retries: 3,\n  retryCondition: (err) =>\n    axiosRetry.isNetworkOrIdempotentRequestError(err) || [429, 502].includes(err.response?.status ?? 0),\n  retryDelay: (retryCount) => retryCount * 1000,\n}\n", "/* eslint-disable brace-style */\nimport * as client from '@botpress/client'\nimport * as common from '../types'\nimport * as types from './types'\n\nexport * from './types'\n\n/**\n * Just like the regular botpress client, but typed with the integration's properties.\n */\nexport class IntegrationSpecificClient<TIntegration extends common.BaseIntegration>\n  implements types.ClientOperations<TIntegration>\n{\n  public constructor(private readonly _client: client.Client) {}\n\n  public createConversation: types.CreateConversation<TIntegration> = ((x) =>\n    this._client.createConversation(x)) as types.CreateConversation<TIntegration>\n  public getConversation: types.GetConversation<TIntegration> = ((x) =>\n    this._client.getConversation(x)) as types.GetConversation<TIntegration>\n  public listConversations: types.ListConversations<TIntegration> = ((x) =>\n    this._client.listConversations(x)) as types.ListConversations<TIntegration>\n  public getOrCreateConversation: types.GetOrCreateConversation<TIntegration> = ((x) =>\n    this._client.getOrCreateConversation(x)) as types.GetOrCreateConversation<TIntegration>\n  public updateConversation: types.UpdateConversation<TIntegration> = ((x) =>\n    this._client.updateConversation(x)) as types.UpdateConversation<TIntegration>\n  public deleteConversation: types.DeleteConversation<TIntegration> = ((x) =>\n    this._client.deleteConversation(x)) as types.DeleteConversation<TIntegration>\n\n  public listParticipants: types.ListParticipants<TIntegration> = ((x) =>\n    this._client.listParticipants(x)) as types.ListParticipants<TIntegration>\n  public addParticipant: types.AddParticipant<TIntegration> = ((x) =>\n    this._client.addParticipant(x)) as types.AddParticipant<TIntegration>\n  public getParticipant: types.GetParticipant<TIntegration> = ((x) =>\n    this._client.getParticipant(x)) as types.GetParticipant<TIntegration>\n  public removeParticipant: types.RemoveParticipant<TIntegration> = ((x) =>\n    this._client.removeParticipant(x)) as types.RemoveParticipant<TIntegration>\n\n  public createEvent: types.CreateEvent<TIntegration> = ((x) =>\n    this._client.createEvent(x)) as types.CreateEvent<TIntegration>\n  public getEvent: types.GetEvent<TIntegration> = ((x) => this._client.getEvent(x)) as types.GetEvent<TIntegration>\n  public listEvents: types.ListEvents<TIntegration> = ((x) =>\n    this._client.listEvents(x)) as types.ListEvents<TIntegration>\n\n  public createMessage: types.CreateMessage<TIntegration> = ((x) =>\n    this._client.createMessage(x)) as types.CreateMessage<TIntegration>\n  public getOrCreateMessage: types.GetOrCreateMessage<TIntegration> = ((x) =>\n    this._client.getOrCreateMessage(x)) as types.GetOrCreateMessage<TIntegration>\n  public getMessage: types.GetMessage<TIntegration> = ((x) =>\n    this._client.getMessage(x)) as types.GetMessage<TIntegration>\n  public updateMessage: types.UpdateMessage<TIntegration> = ((x) =>\n    this._client.updateMessage(x)) as types.UpdateMessage<TIntegration>\n  public listMessages: types.ListMessages<TIntegration> = ((x) =>\n    this._client.listMessages(x)) as types.ListMessages<TIntegration>\n  public deleteMessage: types.DeleteMessage<TIntegration> = ((x) =>\n    this._client.deleteMessage(x)) as types.DeleteMessage<TIntegration>\n\n  public createUser: types.CreateUser<TIntegration> = ((x) =>\n    this._client.createUser(x)) as types.CreateUser<TIntegration>\n  public getUser: types.GetUser<TIntegration> = ((x) => this._client.getUser(x)) as types.GetUser<TIntegration>\n  public listUsers: types.ListUsers<TIntegration> = (x) => this._client.listUsers(x)\n  public getOrCreateUser: types.GetOrCreateUser<TIntegration> = ((x) =>\n    this._client.getOrCreateUser(x)) as types.GetOrCreateUser<TIntegration>\n  public updateUser: types.UpdateUser<TIntegration> = ((x) =>\n    this._client.updateUser(x)) as types.UpdateUser<TIntegration>\n  public deleteUser: types.DeleteUser<TIntegration> = (x) => this._client.deleteUser(x)\n\n  public getState: types.GetState<TIntegration> = ((x) => this._client.getState(x)) as types.GetState<TIntegration>\n  public setState: types.SetState<TIntegration> = ((x) => this._client.setState(x)) as types.SetState<TIntegration>\n  public getOrSetState: types.GetOrSetState<TIntegration> = ((x) =>\n    this._client.getOrSetState(x)) as types.GetOrSetState<TIntegration>\n  public patchState: types.PatchState<TIntegration> = ((x) =>\n    this._client.patchState(x)) as types.PatchState<TIntegration>\n\n  public configureIntegration: types.ConfigureIntegration<TIntegration> = (x) => this._client.configureIntegration(x)\n\n  public uploadFile: types.UploadFile<TIntegration> = (x) => this._client.uploadFile(x)\n  public upsertFile: types.UpsertFile<TIntegration> = (x) => this._client.upsertFile(x)\n  public deleteFile: types.DeleteFile<TIntegration> = (x) => this._client.deleteFile(x)\n  public listFiles: types.ListFiles<TIntegration> = (x) => this._client.listFiles(x)\n  public getFile: types.GetFile<TIntegration> = (x) => this._client.getFile(x)\n  public updateFileMetadata: types.UpdateFileMetadata<TIntegration> = (x) => this._client.updateFileMetadata(x)\n}\n", "export type ActionMetadata = {\n  cost: number\n}\n\nexport class ActionMetadataStore {\n  private _cost: number = 0\n\n  public get cost(): number {\n    return this._cost\n  }\n\n  public setCost(cost: number): void {\n    this._cost = cost\n  }\n\n  public toJSON(): ActionMetadata {\n    return {\n      cost: this.cost,\n    }\n  }\n}\n", "import { z } from '@bpinternal/zui'\nimport {\n  botIdHeader,\n  botUserIdHeader,\n  configurationHeader,\n  configurationTypeHeader,\n  integrationIdHeader,\n  operationHeader,\n  webhookIdHeader,\n} from '../../const'\nimport { IntegrationContext } from './types'\n\nexport const integrationOperationSchema = z.enum([\n  'webhook_received',\n  'message_created',\n  'action_triggered',\n  'register',\n  'unregister',\n  'ping',\n  'create_user',\n  'create_conversation',\n])\n\nexport const extractContext = (headers: Record<string, string | undefined>): IntegrationContext => {\n  const botId = headers[botIdHeader]\n  const botUserId = headers[botUserIdHeader]\n  const integrationId = headers[integrationIdHeader]\n  const webhookId = headers[webhookIdHeader]\n  const configurationType = headers[configurationTypeHeader]\n  const base64Configuration = headers[configurationHeader]\n  const operation = integrationOperationSchema.parse(headers[operationHeader])\n\n  if (!botId) {\n    throw new Error('Missing bot headers')\n  }\n\n  if (!botUserId) {\n    throw new Error('Missing bot user headers')\n  }\n\n  if (!integrationId) {\n    throw new Error('Missing integration headers')\n  }\n\n  if (!webhookId) {\n    throw new Error('Missing webhook headers')\n  }\n\n  if (!base64Configuration) {\n    throw new Error('Missing configuration headers')\n  }\n\n  if (!operation) {\n    throw new Error('Missing operation headers')\n  }\n\n  return {\n    botId,\n    botUserId,\n    integrationId,\n    webhookId,\n    operation,\n    configurationType: configurationType ?? null,\n    configuration: base64Configuration ? JSON.parse(Buffer.from(base64Configuration, 'base64').toString('utf-8')) : {},\n  }\n}\n", "import util from 'util'\n\nconst serializeForBotMessage = (args: Parameters<typeof util.format>) => {\n  if (process.env['BP_LOG_FORMAT'] === 'json') {\n    return JSON.stringify({ msg: util.format(...args), visible_to_bot_owner: true })\n  } else {\n    const [format, ...param] = args\n    return util.format(`[For Bot Owner] ${format}`, ...param)\n  }\n}\n\nexport const integrationLogger = {\n  /**\n   * Use this function to log messages that will be displayed to the Bot Owner.\n   */\n  forBot: () => {\n    return {\n      info: (...args: Parameters<typeof console.info>) => {\n        console.info(serializeForBotMessage(args))\n      },\n      warn: (...args: Parameters<typeof console.warn>) => {\n        console.warn(serializeForBotMessage(args))\n      },\n      error: (...args: Parameters<typeof console.error>) => {\n        console.error(serializeForBotMessage(args))\n      },\n      debug: (...args: Parameters<typeof console.debug>) => {\n        console.debug(serializeForBotMessage(args))\n      },\n    }\n  },\n}\n\nexport type IntegrationLogger = typeof integrationLogger\n", "import type { Server } from 'node:http'\nimport { serve } from '../serve'\nimport {\n  RegisterHandler as RegisterFunction,\n  UnregisterHandler as UnregisterFunction,\n  WebhookHandler as WebhookFunction,\n  CreateUserHandler as CreateUserFunction,\n  CreateConversationHandler as CreateConversationFunction,\n  ActionHandlers as ActionFunctions,\n  ChannelHandlers as ChannelFunctions,\n  integrationHandler,\n} from './server'\nimport { BaseIntegration } from './types'\n\nexport type IntegrationImplementationProps<TIntegration extends BaseIntegration = BaseIntegration> = {\n  register: RegisterFunction<TIntegration>\n  unregister: UnregisterFunction<TIntegration>\n  handler: WebhookFunction<TIntegration>\n  /**\n   * @deprecated\n   */\n  createUser?: CreateUserFunction<TIntegration>\n  /**\n   * @deprecated\n   */\n  createConversation?: CreateConversationFunction<TIntegration>\n  actions: ActionFunctions<TIntegration>\n  channels: ChannelFunctions<TIntegration>\n}\n\nexport class IntegrationImplementation<TIntegration extends BaseIntegration = BaseIntegration> {\n  public readonly actions: IntegrationImplementationProps<TIntegration>['actions']\n  public readonly channels: IntegrationImplementationProps<TIntegration>['channels']\n  public readonly register: IntegrationImplementationProps<TIntegration>['register']\n  public readonly unregister: IntegrationImplementationProps<TIntegration>['unregister']\n  public readonly createUser: IntegrationImplementationProps<TIntegration>['createUser']\n  public readonly createConversation: IntegrationImplementationProps<TIntegration>['createConversation']\n  public readonly webhook: IntegrationImplementationProps<TIntegration>['handler']\n\n  public constructor(public readonly props: IntegrationImplementationProps<TIntegration>) {\n    this.actions = props.actions\n    this.channels = props.channels\n    this.register = props.register\n    this.unregister = props.unregister\n    this.createUser = props.createUser\n    this.createConversation = props.createConversation\n    this.webhook = props.handler\n  }\n\n  public readonly handler = integrationHandler(this as IntegrationImplementation<any>)\n  public readonly start = (port?: number): Promise<Server> => serve(this.handler, port)\n}\n", "import { IntegrationPackage } from '../package'\nimport { SchemaDefinition } from '../schema'\nimport { ValueOf, Writable } from '../utils/type-utils'\nimport z, { AnyZodObject } from '../zui'\n\ntype BaseStates = Record<string, AnyZodObject>\ntype BaseEvents = Record<string, AnyZodObject>\ntype BaseActions = Record<string, AnyZodObject>\n\nexport type TagDefinition = {\n  title?: string\n  description?: string\n}\n\nexport type StateType = 'conversation' | 'user' | 'bot'\n\nexport type StateDefinition<TState extends BaseStates[string] = BaseStates[string]> = SchemaDefinition<TState> & {\n  type: StateType\n  expiry?: number\n}\n\nexport type RecurringEventDefinition<TEvents extends BaseEvents = BaseEvents> = {\n  [K in keyof TEvents]: {\n    type: K\n    payload: z.infer<TEvents[K]>\n    schedule: { cron: string }\n  }\n}[keyof TEvents]\n\nexport type EventDefinition<TEvent extends BaseEvents[string] = BaseEvents[string]> = SchemaDefinition<TEvent>\n\nexport type ConfigurationDefinition = SchemaDefinition\n\nexport type UserDefinition = {\n  tags?: Record<string, TagDefinition>\n}\n\nexport type ConversationDefinition = {\n  tags?: Record<string, TagDefinition>\n}\n\nexport type MessageDefinition = {\n  tags?: Record<string, TagDefinition>\n}\n\nexport type ActionDefinition<TAction extends BaseActions[string] = BaseActions[string]> = {\n  title?: string\n  description?: string\n  input: SchemaDefinition<TAction>\n  output: SchemaDefinition<AnyZodObject> // cannot infer both input and output types (typescript limitation)\n}\n\nexport type IntegrationConfigInstance<I extends IntegrationPackage = IntegrationPackage> = {\n  enabled: boolean\n} & (\n  | {\n      configurationType?: null\n      configuration: z.infer<NonNullable<I['definition']['configuration']>['schema']>\n    }\n  | ValueOf<{\n      [K in keyof NonNullable<I['definition']['configurations']>]: {\n        configurationType: K\n        configuration: z.infer<NonNullable<I['definition']['configurations']>[K]['schema']>\n      }\n    }>\n)\n\nexport type IntegrationInstance = IntegrationPackage & IntegrationConfigInstance\n\nexport type BotDefinitionProps<\n  TStates extends BaseStates = BaseStates,\n  TEvents extends BaseEvents = BaseEvents,\n  TActions extends BaseActions = BaseActions\n> = {\n  integrations?: {\n    [K: string]: IntegrationInstance\n  }\n  user?: UserDefinition\n  conversation?: ConversationDefinition\n  message?: MessageDefinition\n  states?: {\n    [K in keyof TStates]: StateDefinition<TStates[K]>\n  }\n  configuration?: ConfigurationDefinition\n  events?: {\n    [K in keyof TEvents]: EventDefinition<TEvents[K]>\n  }\n  recurringEvents?: Record<string, RecurringEventDefinition<TEvents>>\n  actions?: {\n    [K in keyof TActions]: ActionDefinition<TActions[K]>\n  }\n}\n\nexport class BotDefinition<\n  TStates extends BaseStates = BaseStates,\n  TEvents extends BaseEvents = BaseEvents,\n  TActions extends BaseActions = BaseActions\n> {\n  public readonly integrations: this['props']['integrations']\n  public readonly user: this['props']['user']\n  public readonly conversation: this['props']['conversation']\n  public readonly message: this['props']['message']\n  public readonly states: this['props']['states']\n  public readonly configuration: this['props']['configuration']\n  public readonly events: this['props']['events']\n  public readonly recurringEvents: this['props']['recurringEvents']\n  public readonly actions: this['props']['actions']\n  public constructor(public readonly props: BotDefinitionProps<TStates, TEvents, TActions>) {\n    this.integrations = props.integrations\n    this.user = props.user\n    this.conversation = props.conversation\n    this.message = props.message\n    this.states = props.states\n    this.configuration = props.configuration\n    this.events = props.events\n    this.recurringEvents = props.recurringEvents\n    this.actions = props.actions\n  }\n\n  public add<I extends IntegrationPackage>(integrationPkg: I, config: IntegrationConfigInstance<I>): this {\n    const self = this as Writable<BotDefinition>\n    if (!self.integrations) {\n      self.integrations = {}\n    }\n\n    self.integrations[integrationPkg.definition.name] = {\n      enabled: config.enabled,\n      ...integrationPkg,\n      configurationType: config.configurationType as string,\n      configuration: config.configuration,\n    }\n    return this\n  }\n}\n", "import * as client from '@botpress/client'\nimport { log } from '../../log'\nimport { retryConfig } from '../../retry'\nimport { Request, Response, parseBody } from '../../serve'\nimport * as utils from '../../utils/type-utils'\nimport { BotSpecificClient } from '../client'\nimport * as common from '../types'\nimport { extractContext } from './context'\nimport * as types from './types'\n\nexport * from './types'\n\ntype ServerProps = types.CommonHandlerProps<common.BaseBot> & {\n  req: Request\n}\n\nconst SUCCESS_RESPONSE = { status: 200 }\n\nexport const botHandler =\n  (bot: types.BotHandlers<common.BaseBot>) =>\n  async (req: Request): Promise<Response | void> => {\n    const ctx = extractContext(req.headers)\n\n    const vanillaClient = new client.Client({\n      botId: ctx.botId,\n      retry: retryConfig,\n    })\n    const botClient = new BotSpecificClient<common.BaseBot>(vanillaClient, {\n      before: {\n        createMessage: async (req) => {\n          for (const handler of bot.hooks.before_outgoing_message[req.type] ?? []) {\n            const hookOutput = await handler({\n              client: new BotSpecificClient(vanillaClient),\n              ctx,\n              data: req,\n            })\n            req = hookOutput?.data ?? req\n          }\n          return req\n        },\n        callAction: async (req) => {\n          for (const handler of bot.hooks.before_call_action[req.type] ?? []) {\n            const hookOutput = await handler({\n              client: new BotSpecificClient(vanillaClient),\n              ctx,\n              data: req,\n            })\n            req = hookOutput?.data ?? req\n          }\n          return req\n        },\n      },\n      after: {\n        createMessage: async (res) => {\n          for (const handler of bot.hooks.after_outgoing_message[res.message.type] ?? []) {\n            const hookOutput = await handler({\n              client: new BotSpecificClient(vanillaClient),\n              ctx,\n              data: res,\n            })\n            res = hookOutput?.data ?? res\n          }\n          return res\n        },\n        callAction: async (res) => {\n          for (const handler of bot.hooks.after_call_action[res.output.type] ?? []) {\n            const hookOutput = await handler({\n              client: new BotSpecificClient(vanillaClient),\n              ctx,\n              data: res,\n            })\n            res = hookOutput?.data ?? res\n          }\n          return res\n        },\n      },\n    })\n\n    const props: ServerProps = {\n      req,\n      ctx,\n      client: botClient,\n      self: bot,\n    }\n\n    switch (ctx.operation) {\n      case 'action_triggered':\n        return await onActionTriggered(props)\n      case 'event_received':\n        return await onEventReceived(props)\n      case 'register':\n        return await onRegister(props)\n      case 'unregister':\n        return await onUnregister(props)\n      case 'ping':\n        return await onPing(props)\n      default:\n        throw new Error(`Unknown operation ${ctx.operation}`)\n    }\n  }\n\nconst onPing = async ({ ctx }: ServerProps): Promise<Response> => {\n  log.info(`Received ${ctx.operation} operation for bot ${ctx.botId} of type ${ctx.type}`)\n  return SUCCESS_RESPONSE\n}\n\nconst onRegister = async (_: ServerProps): Promise<Response> => SUCCESS_RESPONSE\n\nconst onUnregister = async (_: ServerProps): Promise<Response> => SUCCESS_RESPONSE\n\nconst onEventReceived = async ({ ctx, req, client, self }: ServerProps): Promise<Response> => {\n  log.debug(`Received event ${ctx.type}`)\n\n  const body = parseBody<types.EventPayload<common.BaseBot>>(req)\n\n  if (ctx.type === 'message_created') {\n    const event = body.event\n    let message: client.Message = event.payload.message\n    for (const handler of self.hooks.before_incoming_message[message.type] ?? []) {\n      const hookOutput = await handler({\n        client,\n        ctx,\n        data: message,\n      })\n      message = hookOutput?.data ?? message\n    }\n\n    const messagePayload: types.MessagePayload<common.BaseBot> = {\n      user: event.payload.user,\n      conversation: event.payload.conversation,\n      states: event.payload.states,\n      message,\n      event,\n    }\n    for (const handler of self.messageHandlers) {\n      await handler({\n        ...messagePayload,\n        client,\n        ctx,\n        self,\n      })\n    }\n\n    for (const handler of self.hooks.after_incoming_message[message.type] ?? []) {\n      const hookOutput = await handler({\n        client,\n        ctx,\n        data: message,\n      })\n      message = hookOutput?.data ?? message\n    }\n\n    return SUCCESS_RESPONSE\n  }\n\n  if (ctx.type === 'state_expired') {\n    const event = body.event\n    const statePayload: types.StateExpiredPayload<common.BaseBot> = { state: event.payload.state }\n    for (const handler of self.stateExpiredHandlers) {\n      await handler({\n        ...statePayload,\n        client,\n        ctx,\n        self,\n      })\n    }\n    return SUCCESS_RESPONSE\n  }\n\n  let event = body.event\n  for (const handler of self.hooks.before_incoming_event[event.type] ?? []) {\n    const hookOutput = await handler({\n      client,\n      ctx,\n      data: event,\n    })\n    event = hookOutput?.data ?? event\n  }\n\n  const eventPayload = { event }\n  for (const handler of self.eventHandlers) {\n    await handler({\n      ...eventPayload,\n      client,\n      ctx,\n      self,\n    })\n  }\n\n  for (const handler of self.hooks.after_incoming_event[event.type] ?? []) {\n    const hookOutput = await handler({\n      client,\n      ctx,\n      data: event,\n    })\n    event = hookOutput?.data ?? event\n  }\n\n  return SUCCESS_RESPONSE\n}\n\nconst onActionTriggered = async ({ ctx, req, client, self }: ServerProps): Promise<Response> => {\n  type AnyActionPayload = utils.ValueOf<types.ActionHandlerPayloads<common.BaseBot>>\n  const { input, type } = parseBody<AnyActionPayload>(req)\n\n  if (!type) {\n    throw new Error('Missing action type')\n  }\n\n  const action = self.actionHandlers[type]\n\n  if (!action) {\n    throw new Error(`Action ${type} not found`)\n  }\n\n  const output = await action({ ctx, input, client, type, self })\n\n  const response = { output }\n  return {\n    status: 200,\n    body: JSON.stringify(response),\n  }\n}\n", "import * as client from '@botpress/client'\nimport * as common from '../types'\nimport * as types from './types'\n\nexport * from './types'\n\n/**\n * Just like the regular botpress client, but typed with the bot's properties.\n */\nexport class BotSpecificClient<TBot extends common.BaseBot> implements types.ClientOperations<TBot> {\n  public constructor(private _client: client.Client, private _hooks: types.ClientHooks = { before: {}, after: {} }) {}\n\n  public getConversation: types.GetConversation<TBot> = ((x) =>\n    this._run('getConversation', x)) as types.GetConversation<TBot>\n  public listConversations: types.ListConversations<TBot> = ((x) =>\n    this._run('listConversations', x)) as types.ListConversations<TBot>\n  public updateConversation: types.UpdateConversation<TBot> = ((x) =>\n    this._run('updateConversation', x)) as types.UpdateConversation<TBot>\n  public deleteConversation: types.DeleteConversation<TBot> = ((x) =>\n    this._run('deleteConversation', x)) as types.DeleteConversation<TBot>\n  public listParticipants: types.ListParticipants<TBot> = ((x) =>\n    this._run('listParticipants', x)) as types.ListParticipants<TBot>\n  public addParticipant: types.AddParticipant<TBot> = ((x) =>\n    this._run('addParticipant', x)) as types.AddParticipant<TBot>\n  public getParticipant: types.GetParticipant<TBot> = ((x) =>\n    this._run('getParticipant', x)) as types.GetParticipant<TBot>\n  public removeParticipant: types.RemoveParticipant<TBot> = ((x) =>\n    this._run('removeParticipant', x)) as types.RemoveParticipant<TBot>\n  public getEvent: types.GetEvent<TBot> = ((x) => this._run('getEvent', x)) as types.GetEvent<TBot>\n  public listEvents: types.ListEvents<TBot> = ((x) => this._run('listEvents', x)) as types.ListEvents<TBot>\n  public createMessage: types.CreateMessage<TBot> = ((x) => this._run('createMessage', x)) as types.CreateMessage<TBot>\n  public getOrCreateMessage: types.GetOrCreateMessage<TBot> = ((x) =>\n    this._run('getOrCreateMessage', x)) as types.GetOrCreateMessage<TBot>\n  public getMessage: types.GetMessage<TBot> = ((x) => this._run('getMessage', x)) as types.GetMessage<TBot>\n  public updateMessage: types.UpdateMessage<TBot> = ((x) => this._run('updateMessage', x)) as types.UpdateMessage<TBot>\n  public listMessages: types.ListMessages<TBot> = ((x) => this._run('listMessages', x)) as types.ListMessages<TBot>\n  public deleteMessage: types.DeleteMessage<TBot> = ((x) => this._run('deleteMessage', x)) as types.DeleteMessage<TBot>\n  public getUser: types.GetUser<TBot> = ((x) => this._run('getUser', x)) as types.GetUser<TBot>\n  public listUsers: types.ListUsers<TBot> = ((x) => this._run('listUsers', x)) as types.ListUsers<TBot>\n  public updateUser: types.UpdateUser<TBot> = ((x) => this._run('updateUser', x)) as types.UpdateUser<TBot>\n  public deleteUser: types.DeleteUser<TBot> = ((x) => this._run('deleteUser', x)) as types.DeleteUser<TBot>\n  public getState: types.GetState<TBot> = ((x) => this._run('getState', x)) as types.GetState<TBot>\n  public setState: types.SetState<TBot> = ((x) => this._run('setState', x)) as types.SetState<TBot>\n  public getOrSetState: types.GetOrSetState<TBot> = ((x) => this._run('getOrSetState', x)) as types.GetOrSetState<TBot>\n  public patchState: types.PatchState<TBot> = ((x) => this._run('patchState', x)) as types.PatchState<TBot>\n  public callAction: types.CallAction<TBot> = ((x) => this._run('callAction', x)) as types.CallAction<TBot>\n  public uploadFile: types.UploadFile<TBot> = ((x) => this._run('uploadFile', x)) as types.UploadFile<TBot>\n  public upsertFile: types.UpsertFile<TBot> = ((x) => this._run('upsertFile', x)) as types.UpsertFile<TBot>\n  public deleteFile: types.DeleteFile<TBot> = ((x) => this._run('deleteFile', x)) as types.DeleteFile<TBot>\n  public listFiles: types.ListFiles<TBot> = ((x) => this._run('listFiles', x)) as types.ListFiles<TBot>\n  public getFile: types.GetFile<TBot> = ((x) => this._run('getFile', x)) as types.GetFile<TBot>\n  public updateFileMetadata: types.UpdateFileMetadata<TBot> = ((x) =>\n    this._run('updateFileMetadata', x)) as types.UpdateFileMetadata<TBot>\n  public searchFiles: types.SearchFiles<TBot> = ((x) => this._run('searchFiles', x)) as types.SearchFiles<TBot>\n\n  /**\n   * @deprecated Use `callAction` to delegate the conversation creation to an integration.\n   */\n  public createConversation: types.CreateConversation<TBot> = (x) => this._client.createConversation(x)\n  /**\n   * @deprecated Use `callAction` to delegate the conversation creation to an integration.\n   */\n  public getOrCreateConversation: types.GetOrCreateConversation<TBot> = (x) => this._client.getOrCreateConversation(x)\n  /**\n   * @deprecated Use `callAction` to delegate the user creation to an integration.\n   */\n  public createUser: types.CreateUser<TBot> = (x) => this._client.createUser(x)\n  /**\n   * @deprecated Use `callAction` to delegate the user creation to an integration.\n   */\n  public getOrCreateUser: types.GetOrCreateUser<TBot> = (x) => this._client.getOrCreateUser(x)\n\n  private _run = async <K extends client.Operation>(\n    operation: K,\n    req: client.ClientInputs[K]\n  ): Promise<client.ClientOutputs[K]> => {\n    const before = this._hooks.before[operation]\n    if (before) {\n      req = await before(req)\n    }\n\n    let res = (await this._client[operation](req as any)) as client.ClientOutputs[K]\n\n    const after = this._hooks.after[operation]\n    if (after) {\n      res = await after(res)\n    }\n\n    return res\n  }\n}\n", "import { z } from '@bpinternal/zui'\nimport { botIdHeader, configurationHeader, operationHeader, typeHeader } from '../../const'\nimport { BotContext } from './types'\n\nconst botOperationSchema = z.enum(['event_received', 'register', 'unregister', 'ping', 'action_triggered'])\nexport const extractContext = (headers: Record<string, string | undefined>): BotContext => {\n  const botId = headers[botIdHeader]\n  const base64Configuration = headers[configurationHeader]\n  const type = headers[typeHeader]\n  const operation = botOperationSchema.parse(headers[operationHeader])\n\n  if (!botId) {\n    throw new Error('Missing bot headers')\n  }\n\n  if (!type) {\n    throw new Error('Missing type headers')\n  }\n\n  if (!base64Configuration) {\n    throw new Error('Missing configuration headers')\n  }\n\n  if (!operation) {\n    throw new Error('Missing operation headers')\n  }\n\n  return {\n    botId,\n    operation,\n    type,\n    configuration: base64Configuration ? JSON.parse(Buffer.from(base64Configuration, 'base64').toString('utf-8')) : {},\n  }\n}\n", "import type { Server } from 'node:http'\nimport { serve } from '../serve'\nimport * as utils from '../utils'\nimport {\n  botHandler,\n  MessageHandler,\n  EventHandler,\n  StateExpiredHandler,\n  HookImplementationsMap,\n  HookDefinitions,\n  HookImplementations,\n  ActionHandlers,\n  BotHandlers,\n} from './server'\nimport { BaseBot } from './types'\n\nexport type BotImplementationProps<TBot extends BaseBot = BaseBot> = {\n  actions: ActionHandlers<TBot>\n}\n\nexport class BotImplementation<TBot extends BaseBot = BaseBot> {\n  public readonly actionHandlers: ActionHandlers<TBot>\n  public readonly messageHandlers: MessageHandler<TBot>[] = []\n  public readonly eventHandlers: EventHandler<TBot>[] = []\n  public readonly stateExpiredHandlers: StateExpiredHandler<TBot>[] = []\n  public readonly hooks: HookImplementationsMap<TBot> = {\n    before_incoming_event: {},\n    before_incoming_message: {},\n    before_outgoing_message: {},\n    before_call_action: {},\n    after_incoming_event: {},\n    after_incoming_message: {},\n    after_outgoing_message: {},\n    after_call_action: {},\n  }\n\n  public constructor(public readonly props: BotImplementationProps<TBot>) {\n    this.actionHandlers = props.actions\n  }\n\n  public readonly message = (handler: MessageHandler<TBot>): void => {\n    this.messageHandlers.push(handler)\n  }\n\n  public readonly event = (handler: EventHandler<TBot>): void => {\n    this.eventHandlers.push(handler)\n  }\n\n  public readonly stateExpired = (handler: StateExpiredHandler<TBot>): void => {\n    this.stateExpiredHandlers.push(handler)\n  }\n\n  public readonly hook = {\n    before_incoming_event: <T extends keyof HookDefinitions<TBot>['before_incoming_event']>(\n      type: T,\n      handler: HookImplementations<TBot>['before_incoming_event'][T]\n    ) => {\n      this.hooks.before_incoming_event[type] = utils.arrays.safePush(this.hooks.before_incoming_event[type], handler)\n    },\n    before_incoming_message: <T extends keyof HookDefinitions<TBot>['before_incoming_message']>(\n      type: T,\n      handler: HookImplementations<TBot>['before_incoming_message'][T]\n    ) => {\n      this.hooks.before_incoming_message[type] = utils.arrays.safePush(\n        this.hooks.before_incoming_message[type],\n        handler\n      )\n    },\n    before_outgoing_message: <T extends keyof HookDefinitions<TBot>['before_outgoing_message']>(\n      type: T,\n      handler: HookImplementations<TBot>['before_outgoing_message'][T]\n    ) => {\n      this.hooks.before_outgoing_message[type] = utils.arrays.safePush(\n        this.hooks.before_outgoing_message[type],\n        handler\n      )\n    },\n    before_call_action: <T extends keyof HookDefinitions<TBot>['before_call_action']>(\n      type: T,\n      handler: HookImplementations<TBot>['before_call_action'][T]\n    ) => {\n      this.hooks.before_call_action[type] = utils.arrays.safePush(this.hooks.before_call_action[type], handler)\n    },\n    after_incoming_event: <T extends keyof HookDefinitions<TBot>['after_incoming_event']>(\n      type: T,\n      handler: HookImplementations<TBot>['after_incoming_event'][T]\n    ) => {\n      this.hooks.after_incoming_event[type] = utils.arrays.safePush(this.hooks.after_incoming_event[type], handler)\n    },\n    after_incoming_message: <T extends keyof HookDefinitions<TBot>['after_incoming_message']>(\n      type: T,\n      handler: HookImplementations<TBot>['after_incoming_message'][T]\n    ) => {\n      this.hooks.after_incoming_message[type] = utils.arrays.safePush(this.hooks.after_incoming_message[type], handler)\n    },\n    after_outgoing_message: <T extends keyof HookDefinitions<TBot>['after_outgoing_message']>(\n      type: T,\n      handler: HookImplementations<TBot>['after_outgoing_message'][T]\n    ) => {\n      this.hooks.after_outgoing_message[type] = utils.arrays.safePush(this.hooks.after_outgoing_message[type], handler)\n    },\n    after_call_action: <T extends keyof HookDefinitions<TBot>['after_call_action']>(\n      type: T,\n      handler: HookImplementations<TBot>['after_call_action'][T]\n    ) => {\n      this.hooks.after_call_action[type] = utils.arrays.safePush(this.hooks.after_call_action[type], handler)\n    },\n  }\n\n  public readonly handler = botHandler(this as BotHandlers<any>)\n\n  public readonly start = (port?: number): Promise<Server> => serve(this.handler, port)\n}\n", "import { ActionDefinition, ChannelDefinition, EntityDefinition, EventDefinition } from '../integration/definition'\nimport * as utils from '../utils'\nimport z, { AnyZodObject, GenericZuiSchema, ZodRef } from '../zui'\n\ntype BaseEvents = Record<string, AnyZodObject>\ntype BaseActions = Record<string, AnyZodObject>\ntype BaseMessages = Record<string, AnyZodObject>\ntype BaseChannels = Record<string, BaseMessages>\ntype BaseEntities = Record<string, AnyZodObject>\n\ntype EntityReferences<TEntities extends BaseEntities> = {\n  [K in keyof TEntities]: ZodRef\n}\n\ntype GenericEventDefinition<TEntities extends BaseEntities, TEvent extends BaseEvents[string] = BaseEvents[string]> = {\n  schema: GenericZuiSchema<EntityReferences<TEntities>, TEvent>\n}\n\ntype GenericChannelDefinition<\n  TEntities extends BaseEntities,\n  TChannel extends BaseChannels[string] = BaseChannels[string]\n> = {\n  messages: {\n    [K in keyof TChannel]: {\n      schema: GenericZuiSchema<EntityReferences<TEntities>, TChannel[K]>\n    }\n  }\n}\n\ntype GenericActionDefinition<\n  TEntities extends BaseEntities,\n  TAction extends BaseActions[string] = BaseActions[string]\n> = {\n  billable?: boolean\n  cacheable?: boolean\n  input: { schema: GenericZuiSchema<EntityReferences<TEntities>, TAction> }\n  output: { schema: GenericZuiSchema<EntityReferences<TEntities>, AnyZodObject> }\n}\n\nexport type InterfaceDeclarationProps<\n  TEntities extends BaseEntities = BaseEntities,\n  TActions extends BaseActions = BaseActions,\n  TEvents extends BaseEntities = BaseEntities,\n  TChannels extends BaseChannels = BaseChannels\n> = {\n  name: string\n  version: string\n\n  entities?: {\n    [K in keyof TEntities]: EntityDefinition<TEntities[K]>\n  }\n\n  events?: { [K in keyof TEvents]: GenericEventDefinition<TEntities, TEvents[K]> }\n\n  actions?: {\n    [K in keyof TActions]: GenericActionDefinition<TEntities, TActions[K]>\n  }\n\n  channels?: {\n    [K in keyof TChannels]: GenericChannelDefinition<TEntities, TChannels[K]>\n  }\n\n  templateName?: string\n}\n\nexport class InterfaceDeclaration<\n  TEntities extends BaseEntities = BaseEntities,\n  TActions extends BaseActions = BaseActions,\n  TEvents extends BaseEvents = BaseEvents,\n  TChannels extends BaseChannels = BaseChannels\n> {\n  public readonly name: this['props']['name']\n  public readonly version: this['props']['version']\n\n  public readonly entities: { [K in keyof TEntities]: EntityDefinition<TEntities[K]> }\n  public readonly events: { [K in keyof TEvents]: EventDefinition<TEvents[K]> }\n  public readonly actions: { [K in keyof TActions]: ActionDefinition<TActions[K]> }\n  public readonly channels: { [K in keyof TChannels]: ChannelDefinition<TChannels[K]> }\n\n  public readonly templateName: this['props']['templateName']\n\n  public constructor(public readonly props: InterfaceDeclarationProps<TEntities, TActions, TEvents, TChannels>) {\n    this.name = props.name\n    this.version = props.version\n    this.entities = props.entities ?? ({} as this['entities'])\n    this.templateName = props.templateName\n\n    const entityReferences = this._getEntityReference(this.entities)\n\n    const events: Record<string, EventDefinition> =\n      props.events === undefined\n        ? {}\n        : utils.records.mapValues(\n            props.events,\n            (event): EventDefinition => ({\n              ...event,\n              schema: event.schema(entityReferences),\n            })\n          )\n\n    const actions: Record<string, ActionDefinition> =\n      props.actions === undefined\n        ? {}\n        : utils.records.mapValues(\n            props.actions,\n            (action): ActionDefinition => ({\n              ...action,\n              input: {\n                ...action.input,\n                schema: action.input.schema(entityReferences),\n              },\n              output: {\n                ...action.output,\n                schema: action.output.schema(entityReferences),\n              },\n            })\n          )\n\n    const channels: Record<string, ChannelDefinition> =\n      props.channels === undefined\n        ? {}\n        : utils.records.mapValues(\n            props.channels,\n            (channel): ChannelDefinition => ({\n              ...channel,\n              messages: utils.records.mapValues(channel.messages, (message) => ({\n                ...message,\n                schema: message.schema(entityReferences),\n              })),\n            })\n          )\n\n    this.events = events as this['events']\n    this.actions = actions as this['actions']\n    this.channels = channels as this['channels']\n  }\n\n  private _getEntityReference = (entities: this['entities']): EntityReferences<TEntities> => {\n    const entityReferences: Record<string, ZodRef> = {} as EntityReferences<TEntities>\n    for (const entityName of Object.keys(entities)) {\n      entityReferences[entityName] = z.ref(entityName)\n    }\n    return entityReferences as EntityReferences<TEntities>\n  }\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "BotImplementation", "BotDefinition", "BotSpecificClient", "IntegrationImplementation", "IntegrationDefinition", "IntegrationSpecificClient", "InterfaceDeclaration", "botIdHeader", "botUserIdHeader", "configurationHeader", "configurationTypeHeader", "integrationIdHeader", "message_exports", "operationHeader", "parseBody", "serve", "typeHeader", "webhookIdHeader", "__toCommonJS", "message_exports", "__export", "defaults", "markdown", "zui_exports", "__export", "zui_default", "import_zui", "__reExport", "NonEmptyString", "textMessageSchema", "markdownMessageSchema", "imageMessageSchema", "audioMessageSchema", "videoMessageSchema", "fileMessageSchema", "locationMessageSchema", "cardSchema", "choiceSchema", "carouselSchema", "blocSchema", "blocsSchema", "markdown", "defaults", "botIdHeader", "botUserIdHeader", "integrationIdHeader", "webhookIdHeader", "configurationTypeHeader", "configurationHeader", "operationHeader", "typeHeader", "import_node_http", "log", "parseBody", "req", "serve", "handler", "port", "callback", "defaultCallback", "server", "res", "request", "mapIncomingMessageToRequest", "response", "e", "log", "incoming", "body", "readBody", "headers", "i", "key", "value", "url", "trimPrefix", "prefix", "resolve", "reject", "chunk", "__reExport", "src_exports", "zui_exports", "import_client", "record_utils_exports", "__export", "mapValues", "pairs", "obj", "fn", "key", "value", "array_utils_exports", "__export", "safePush", "arr", "value", "schemaName", "createStore", "props", "record_utils_exports", "e", "k", "isBranded", "schema", "getName", "IntegrationDefinition", "props", "interfacePkg", "builder", "extensionBuilderOutput", "createStore", "unbrandedEntity", "record_utils_exports", "_k", "e", "isBranded", "self", "interfaceTypeArguments", "getName", "entityNames", "key", "import_client", "import_client", "retryConfig", "err", "retryCount", "IntegrationSpecificClient", "_client", "x", "ActionMetadataStore", "cost", "import_zui", "integrationOperationSchema", "extractContext", "headers", "botId", "botIdHeader", "botUserId", "botUserIdHeader", "integrationId", "integrationIdHeader", "webhookId", "webhookIdHeader", "configurationType", "configurationTypeHeader", "base64Configuration", "configurationHeader", "operation", "operationHeader", "import_util", "serializeForBotMessage", "args", "util", "format", "param", "integrationLogger", "integrationHandler", "instance", "req", "ctx", "extractContext", "vanillaClient", "retryConfig", "client", "IntegrationSpecificClient", "props", "integrationLogger", "response", "onWebhook", "onRegister", "onUnregister", "onMessageCreated", "onActionTriggered", "onPing", "onCreateUser", "onCreateConversation", "thrown", "runtimeError", "_", "incomingRequest", "logger", "parseBody", "webhookUrl", "tags", "channel", "conversation", "user", "type", "payload", "message", "channelHandler", "messageHandler", "input", "action", "metadata", "ActionMetadataStore", "IntegrationImplementation", "props", "integrationHandler", "port", "serve", "BotDefinition", "props", "integrationPkg", "config", "self", "client", "BotSpecificClient", "_client", "_hooks", "x", "operation", "req", "before", "res", "after", "import_zui", "botOperationSchema", "extractContext", "headers", "botId", "botIdHeader", "base64Configuration", "configurationHeader", "type", "typeHeader", "operation", "operationHeader", "SUCCESS_RESPONSE", "botHandler", "bot", "req", "ctx", "extractContext", "vanillaClient", "retryConfig", "botClient", "BotSpecificClient", "handler", "res", "props", "onActionTriggered", "onEventReceived", "onRegister", "onUnregister", "onPing", "log", "_", "client", "self", "body", "parseBody", "event", "message", "messagePayload", "statePayload", "eventPayload", "input", "type", "action", "response", "BotImplementation", "props", "handler", "type", "array_utils_exports", "botHandler", "port", "serve", "InterfaceDeclaration", "props", "entityReferences", "events", "record_utils_exports", "event", "actions", "action", "channels", "channel", "message", "entities", "entityName", "zui_default"]
}
